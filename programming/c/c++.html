<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-12-29 Sun 22:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Victor Chen" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/font.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/htmlize.css"/>
<script type="text/javascript" src="../../styles/readtheorg/js/jquery.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9ef9ccb">1 Type</a>
<ul>
<li><a href="#org73257d7">1.1 Type List</a></li>
<li><a href="#orgf64239b">1.2 Character</a></li>
<li><a href="#org0f03fae">1.3 Array</a></li>
<li><a href="#org308e229">1.4 String</a>
<ul>
<li><a href="#org893fb2d">1.4.1 语法</a></li>
<li><a href="#org9331ab3">1.4.2 运算</a></li>
<li><a href="#org8f51543">1.4.3 指针</a></li>
</ul>
</li>
<li><a href="#orgfedc8dc">1.5 列表</a>
<ul>
<li><a href="#org70f9f74">1.5.1 示例</a></li>
</ul>
</li>
<li><a href="#org595528c">1.6 类型检验</a></li>
<li><a href="#org8c75a4c">1.7 类型转换</a>
<ul>
<li><a href="#orgd296c41">1.7.1 隐式类型转换</a></li>
<li><a href="#org2a24a55">1.7.2 显式类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3a24827">2 变量</a>
<ul>
<li><a href="#orgc263c34">2.1 声明 vs 定义</a></li>
<li><a href="#orge83fba0">2.2 语法</a></li>
<li><a href="#org30e594f">2.3 作用域</a></li>
<li><a href="#orgab576f0">2.4 类型</a></li>
<li><a href="#org68319a3">2.5 全局变量</a>
<ul>
<li><a href="#orga62b601">2.5.1 示例</a></li>
<li><a href="#org2ea97a4">2.5.2 <code>extern</code></a></li>
</ul>
</li>
<li><a href="#org68d44c9">2.6 静态全局变量</a></li>
</ul>
</li>
<li><a href="#orgd8d6202">3 常量</a>
<ul>
<li><a href="#org7adf6f9">3.1 语法</a></li>
<li><a href="#orgd4dbf23">3.2 枚举常量</a></li>
<li><a href="#org4fa3abb">3.3 符号常量</a></li>
<li><a href="#orgbb25f5e">3.4 宏</a></li>
</ul>
</li>
<li><a href="#orgb7819e8">4 运算符</a>
<ul>
<li><a href="#orgce2a89e">4.1 优先级</a></li>
<li><a href="#orgd9921e7">4.2 数学运算符</a></li>
<li><a href="#org30d0796">4.3 逻辑运算符</a></li>
<li><a href="#org6ad22a6">4.4 一元运算符</a></li>
<li><a href="#orgbefd8db">4.5 指针运算符</a></li>
<li><a href="#org2b17391">4.6 <code>new</code></a></li>
<li><a href="#org855d6f1">4.7 <code>delete</code></a></li>
<li><a href="#org50dd72b">4.8 <code>sizeof</code></a></li>
<li><a href="#orgdd14707">4.9 <code>&gt;&gt;</code></a></li>
<li><a href="#org1501a8c">4.10 运算符重载</a>
<ul>
<li><a href="#org043e114">4.10.1 重载 <code>&lt;&lt;</code></a></li>
<li><a href="#org166ce3e">4.10.2 重载 <code>&lt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge888522">5 指针</a>
<ul>
<li><a href="#org6c2f0ec">5.1 内存</a></li>
<li><a href="#org8a79ab6">5.2 运算符</a></li>
<li><a href="#org2d93b80">5.3 语法</a></li>
<li><a href="#orgf6d31b1">5.4 指针数组</a></li>
</ul>
</li>
<li><a href="#orgdb01da5">6 语句</a>
<ul>
<li><a href="#orgeb15b6a">6.1 <code>for</code></a>
<ul>
<li><a href="#orgd4ad3e2">6.1.1 一般循环</a></li>
<li><a href="#orgbd5b3fb">6.1.2 迭代循环</a></li>
</ul>
</li>
<li><a href="#org008173b">6.2 <code>if</code></a></li>
<li><a href="#orga5ea377">6.3 <code>switch</code></a></li>
<li><a href="#org0c9c72d">6.4 <code>try</code> <code>catch</code></a></li>
<li><a href="#orgc6248e2">6.5 <code>while</code></a></li>
<li><a href="#org333e98f">6.6 注释</a></li>
</ul>
</li>
<li><a href="#org18adeef">7 函数</a>
<ul>
<li><a href="#orgde3cf71">7.1 定义</a></li>
<li><a href="#org169ec23">7.2 内存</a></li>
<li><a href="#org6cf2153">7.3 参数</a>
<ul>
<li><a href="#orge96fe8c">7.3.1 类型</a></li>
<li><a href="#orgd89af25">7.3.2 传值</a></li>
<li><a href="#org287be39">7.3.3 传引用</a></li>
<li><a href="#org5f18215">7.3.4 默认值</a></li>
</ul>
</li>
<li><a href="#org79dd2d7">7.4 返回值</a></li>
<li><a href="#orge0d3d30">7.5 原型</a></li>
<li><a href="#org3e27635">7.6 模板</a></li>
</ul>
</li>
<li><a href="#org767192a">8 OO</a>
<ul>
<li><a href="#org44f63ad">8.1 类</a>
<ul>
<li><a href="#orgb7d044c">8.1.1 定义</a></li>
<li><a href="#org94025af">8.1.2 实例化</a></li>
<li><a href="#org348de23">8.1.3 继承</a></li>
<li><a href="#org445224b">8.1.4 示例</a></li>
</ul>
</li>
<li><a href="#org824adb0">8.2 抽象类</a></li>
<li><a href="#org398dd43">8.3 模板</a></li>
<li><a href="#orgec1aae0">8.4 <code>friend</code></a></li>
<li><a href="#orgf9afd83">8.5 可见性</a></li>
<li><a href="#org603606a">8.6 成员变量</a>
<ul>
<li><a href="#orgd776ceb">8.6.1 静态成员变量</a></li>
</ul>
</li>
<li><a href="#orgc018a42">8.7 成员函数</a>
<ul>
<li><a href="#orgd3ff439">8.7.1 定义</a></li>
<li><a href="#orgf65b5c5">8.7.2 执行</a></li>
<li><a href="#org5e0a0a2">8.7.3 继承</a></li>
<li><a href="#org1afa315">8.7.4 <code>this</code></a></li>
</ul>
</li>
<li><a href="#orgee5b019">8.8 虚拟函数</a>
<ul>
<li><a href="#orgd22f3ab">8.8.1 完全虚拟函数</a></li>
</ul>
</li>
<li><a href="#org3106205">8.9 构造函数</a>
<ul>
<li><a href="#org8a40443">8.9.1 基类构造函数</a></li>
<li><a href="#org4ce3e82">8.9.2 复制构造函数</a></li>
</ul>
</li>
<li><a href="#org10c771b">8.10 析构函数</a>
<ul>
<li><a href="#orgb7489b3">8.10.1 虚拟析构函数</a></li>
</ul>
</li>
<li><a href="#org966f8a6">8.11 函数原型</a></li>
</ul>
</li>
<li><a href="#orgcf8e838">9 程序</a>
<ul>
<li><a href="#org7e14864">9.1 头文件</a></li>
<li><a href="#orgd480184">9.2 源码文件</a></li>
<li><a href="#orgc30ae79">9.3 客户文件</a></li>
<li><a href="#orgc939d0a">9.4 <code>#include</code></a></li>
<li><a href="#org99fcff9">9.5 <code>main()</code></a></li>
</ul>
</li>
<li><a href="#org363956c">10 编译</a>
<ul>
<li><a href="#orgd06452c">10.1 编译过程</a></li>
<li><a href="#orgbb0357d">10.2 编译器</a></li>
<li><a href="#org415c566">10.3 <code>g++</code></a></li>
<li><a href="#org6864754">10.4 <code>make</code></a></li>
<li><a href="#orgc46dd34">10.5 <code>makefile</code></a></li>
</ul>
</li>
<li><a href="#org309a62c">11 Links</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9ef9ccb" class="outline-2">
<h2 id="org9ef9ccb"><span class="section-number-2">1</span> Type</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-org73257d7" class="outline-3">
<h3 id="org73257d7"><span class="section-number-3">1.1</span> Type List</h3>
<div class="outline-text-3" id="text-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">字节</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>整数</b></td>
<td class="org-left"><code>short (int)</code></td>
<td class="org-right">2</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>int</code></td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>long (int)</code></td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>long long (int)</code></td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>浮点数</b></td>
<td class="org-left"><code>float</code></td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>double</code></td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>long double</code></td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>字符</b></td>
<td class="org-left"><code>char</code></td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>char16_t</code></td>
<td class="org-right">2</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>char32_t</code></td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>wchar_t</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">表示支持的最大字符集的字符</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>string</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
具体字节数因编译器而定。
</p>
</div>
</div>

<div id="outline-container-orgf64239b" class="outline-3">
<h3 id="orgf64239b"><span class="section-number-3">1.2</span> Character</h3>
<div class="outline-text-3" id="text-1-2">
<p>
字符由 <code>'</code> 包围时，表示它对应的整数值，即字符码（character code）。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-string">'A'</span> == 65;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f03fae" class="outline-3">
<h3 id="org0f03fae"><span class="section-number-3">1.3</span> Array</h3>
<div class="outline-text-3" id="text-1-3">
<p>
数组中只能存储同一数据类型的元素，因为每个元素占用的内存空间相同，才可以使用数组索引值迅速定位元素位置。
</p>

<p>
数组定义：
</p>

<div class="org-src-container">
<pre class="src src-cpp">&lt;type&gt; &lt;name&gt;[&lt;size&gt;];
</pre>
</div>

<p>
定义之后，数组名成为一个常量指针，指向数组第一个元素。
</p>

<p>
数组初始化：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">foo</span>[10] = {1, 2, 3}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#23450;&#21069;&#19977;&#20010;&#20803;&#32032;&#65292;&#20043;&#21518;&#40664;&#35748;&#20026; 0</span>
<span class="org-type">int</span> <span class="org-variable-name">foo</span>[10] = {0};       <span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#37096;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026; 0</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org308e229" class="outline-3">
<h3 id="org308e229"><span class="section-number-3">1.4</span> String</h3>
<div class="outline-text-3" id="text-1-4">
<p>
字符串实质是字符数组。由 null 字符 <code>\0</code> 结尾，字符串操作函数通过 null 字符来确定字符串的结尾。
</p>

<p>
字符串与字符的区别是由 <code>"</code> 包围。 
</p>
</div>

<div id="outline-container-org893fb2d" class="outline-4">
<h4 id="org893fb2d"><span class="section-number-4">1.4.1</span> 语法</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span><code>char*</code></label><pre class="src src-cpp"><span class="org-type">char</span>* &lt;name&gt;;
<span class="org-type">char</span>* &lt;name&gt; = <span class="org-string">"&lt;string&gt;"</span>;
&lt;name&gt; = <span class="org-keyword">new</span> <span class="org-type">char</span>[&lt;size&gt;];

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20989;&#25968;&#21442;&#25968;&#19982;&#36820;&#22238;&#20540;</span>
<span class="org-type">char</span>* <span class="org-function-name">foo</span>(<span class="org-type">char</span>* <span class="org-variable-name">str</span>) {
  <span class="org-keyword">return</span> <span class="org-string">"output"</span>;
}
cout &lt;&lt; foo(<span class="org-string">"input"</span>) &lt;&lt; endl;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span><code>string</code></label><pre class="src src-cpp"><span class="org-type">string</span> &lt;name&gt;;
<span class="org-type">string</span> &lt;name&gt; = <span class="org-string">"&lt;string&gt;"</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org9331ab3" class="outline-4">
<h4 id="org9331ab3"><span class="section-number-4">1.4.2</span> 运算</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">string</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>;
<span class="org-type">int</span> <span class="org-variable-name">l</span> = a.size(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38271;&#24230;</span>
a = b + c;        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f51543" class="outline-4">
<h4 id="org8f51543"><span class="section-number-4">1.4.3</span> 指针</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li>在表达式中，字符串的值是指向字符数组第一个元素的指针。</li>
<li>当字符串用于调用函数时，传入的是指向字符数组第一个元素的指针。</li>
<li>当函数返回字符串时，返回值是指向字符数组第一个元素的指针。</li>
</ul>


<div class="figure">
<p><img src="../images/c++/04.png" alt="04.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfedc8dc" class="outline-3">
<h3 id="orgfedc8dc"><span class="section-number-3">1.5</span> 列表</h3>
<div class="outline-text-3" id="text-1-5">
<p>
When using a list, instead of an array, there is no need to anticipate how many objects will be stored, so it can conserve the space that would be wasted by safe worst-case estimates.
</p>

<p>
当多个对象通过指针链接在一起时，这些对象就属于一个 <b>列表</b> ，其中每一个对象称为列表的一个 <b>元素</b> 。
</p>

<dl class="org-dl">
<dt>内部指针</dt><dd>在类中设置一个指针成员变量，使其指向另一个此类对象，以此将多个对象串联在一起。<br />
通常不采用这种方式，因为需要对现有的、已经过测试的类进行修改，而且如果对象属于多个列表，则需要多个内部指针。</dd>

<dt>外部指针</dt><dd>定义一个新类，包含两个指针成员变量，一个指向下一个此类对象，另一个指向列表元素对象。<br />
不需要修改现有类，可以创建多个列表，而且列表元素可以是子类的对象。</dd>
</dl>
</div>

<div id="outline-container-org70f9f74" class="outline-4">
<h4 id="org70f9f74"><span class="section-number-4">1.5.1</span> 示例</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
从头部插入元素的列表。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>定义</label><pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">element_param</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">element</span> {
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">list</span>&lt;<span class="org-type">element_param</span>&gt;;
  <span class="org-keyword">private</span>:
    <span class="org-type">element</span> *<span class="org-variable-name">next</span>;
    <span class="org-type">element_param</span> *<span class="org-variable-name">object</span>;
    <span class="org-function-name">element</span>(<span class="org-type">element_param</span> *<span class="org-variable-name">o</span>, <span class="org-type">element</span> *<span class="org-variable-name">e</span>) {
      object = o;
      next = e;
    }
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">list_param</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">list</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">list</span>() {
      first = <span class="org-constant">NULL</span>;
      current = first;
    }
    <span class="org-type">void</span> <span class="org-function-name">add</span>(<span class="org-type">list_param</span> *<span class="org-variable-name">object</span>) {
      first = <span class="org-keyword">new</span> element&lt;<span class="org-type">list_param</span>&gt;(object, first);
      current = first;
    }
    <span class="org-type">void</span> <span class="org-function-name">advance</span>() {
      current = current-&gt;next;
    }
    <span class="org-type">int</span> <span class="org-function-name">is_end</span>() {
      <span class="org-keyword">return</span> <span class="org-negation-char">!</span>current;
    }
    <span class="org-type">void</span> <span class="org-function-name">reset</span>() {
      current = first;
    }
    <span class="org-type">list_param</span>* <span class="org-function-name">access</span>() {
      <span class="org-keyword">return</span> current-&gt;object;
    }
  <span class="org-keyword">private</span>:
    <span class="org-type">element</span>&lt;<span class="org-type">list_param</span>&gt; *<span class="org-variable-name">first</span>;
    <span class="org-type">element</span>&lt;<span class="org-type">list_param</span>&gt; *<span class="org-variable-name">current</span>;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>使用</label><pre class="src src-cpp"><span class="org-type">list</span> <span class="org-variable-name">my_list</span>;
my_list.add(<span class="org-keyword">new</span> <span class="org-type">foo</span>());
...
my_list.reset();
<span class="org-keyword">for</span> (; <span class="org-negation-char">!</span>my_list.is_end(); my_list.advance()) {
  cout &lt;&lt; my_list.access()-&gt;attr &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org595528c" class="outline-3">
<h3 id="org595528c"><span class="section-number-3">1.6</span> 类型检验</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Foo</span>* <span class="org-variable-name">test</span> = <span class="org-keyword">dynamic_cast</span> &lt;<span class="org-type">Foo</span>*&gt; (obj);
<span class="org-keyword">if</span> (test != <span class="org-constant">NULL</span>)
    cout &lt;&lt; <span class="org-string">"object of class Foo"</span> &lt;&lt; end;
<span class="org-keyword">else</span>
    cout &lt;&lt; <span class="org-string">"not object of class Foo"</span> &lt;&lt; endl;
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c75a4c" class="outline-3">
<h3 id="org8c75a4c"><span class="section-number-3">1.7</span> 类型转换</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-orgd296c41" class="outline-4">
<h4 id="orgd296c41"><span class="section-number-4">1.7.1</span> 隐式类型转换</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
当数学运算的操作数为不同类型时，较短的类型会被自动转换为较长的类型，以不丢失信息，如 <code>int</code> 与 <code>float</code> 进行运算时被转换为 <code>float</code> 。
</p>

<p>
当长类型的值被赋值给短类型的变量时，编译器会给出警告，如 <code>float</code> 值被赋给 <code>int</code> 变量。
</p>
</div>
</div>

<div id="outline-container-org2a24a55" class="outline-4">
<h4 id="org2a24a55"><span class="section-number-4">1.7.2</span> 显式类型转换</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">
<pre class="src src-cpp">(&lt;type&gt;) &lt;expr&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>示例</label><pre class="src src-cpp">a = (<span class="org-type">double</span>) b;
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org3a24827" class="outline-2">
<h2 id="org3a24827"><span class="section-number-2">2</span> 变量</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgc263c34" class="outline-3">
<h3 id="orgc263c34"><span class="section-number-3">2.1</span> 声明 vs 定义</h3>
<div class="outline-text-3" id="text-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b>声明：</b></th>
<th scope="col" class="org-left">告知编译器一个标识符（变量、函数、参数）占用的内存空间（数据类型的长度），但不分配内存。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>定义：</b></td>
<td class="org-left">使编译器在编译时分配内存。</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>变量只可以被定义一次，但可以声明多次（比如通过 <code>extern</code> ）。</li>
<li>当在所有函数体外引入一个变量时，它同时被声明和定义。</li>
<li>当在函数体内引入一个变量时，它只被声明，而不被定义。</li>
</ul>
</div>
</div>

<div id="outline-container-orge83fba0" class="outline-3">
<h3 id="orge83fba0"><span class="section-number-3">2.2</span> 语法</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>声明</label><pre class="src src-cpp">&lt;type&gt; &lt;name&gt;;
&lt;type&gt; &lt;name&gt;, ...;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>初始化</label><pre class="src src-cpp">&lt;type&gt; &lt;name&gt; = &lt;expr&gt;;
&lt;type&gt; &lt;name&gt; = &lt;expr&gt;, ...;
</pre>
</div>
</div>
</div>

<div id="outline-container-org30e594f" class="outline-3">
<h3 id="org30e594f"><span class="section-number-3">2.3</span> 作用域</h3>
<div class="outline-text-3" id="text-2-3">
<dl class="org-dl">
<dt>Extent</dt><dd>The extent of a variable is the time during which a chunk of memory is allocated for that variable. <br />
The memory set aside for a global variable is never reallocated, so global variables are said to have <b>static extent</b>. <br />
The memory allocated for parameters and local variables is reallocated as soon as the corresponding function has finished executing, so parameters and local variables are said to have <b>dynamic extent</b>.</dd>

<dt>Scope</dt><dd>The scope of a variable is that portion of a program where that variable can be evaluated or assigned. <br />
Global variables can be evaluated and assigned at any point in a program after they are defined, so global variables are said to have <b>universal scope</b>.
Parameters and local variables can be evaluated and assigned only in the function in which they are declared. Accordingly, parameters and local variables are said to have <b>local scope</b>.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgab576f0" class="outline-3">
<h3 id="orgab576f0"><span class="section-number-3">2.4</span> 类型</h3>
<div class="outline-text-3" id="text-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b>本地变量</b></th>
<th scope="col" class="org-left">在函数内定义的变量。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>全局变量</b></td>
<td class="org-left">在（所有）函数外定义的变量。</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>静态全局变量</b></td>
<td class="org-left">作用域只在一个文件内的全局变量。</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org68319a3" class="outline-3">
<h3 id="org68319a3"><span class="section-number-3">2.5</span> 全局变量</h3>
<div class="outline-text-3" id="text-2-5">
<p>
在全局变量之后定义的函数，都可以使用该全局变量的值。
</p>
</div>

<div id="outline-container-orga62b601" class="outline-4">
<h4 id="orga62b601"><span class="section-number-4">2.5.1</span> 示例</h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#23616;&#21464;&#37327;</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span> = 18;
<span class="org-type">int</span> <span class="org-variable-name">b</span> = 6;

<span class="org-type">int</span> <span class="org-function-name">function1</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#21517;&#30340;&#26412;&#22320;&#21464;&#37327;&#35206;&#30422;&#65288;override&#65289;&#20840;&#23616;&#21464;&#37327;</span>
  <span class="org-keyword">return</span> a - b;
}

<span class="org-type">int</span> <span class="org-function-name">function2</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">c</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;&#20840;&#23616;&#21464;&#37327;</span>
  c = a + b;
  <span class="org-keyword">return</span> c;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#21517;&#30340;&#26412;&#22320;&#21464;&#37327;&#35206;&#30422;&#65288;override&#65289;&#20840;&#23616;&#21464;&#37327;</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> = 12;
  <span class="org-type">int</span> <span class="org-variable-name">c</span> = 0;
  a = function1(b, a); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#23616; a = &#26412;&#22320; b - &#20840;&#23616; a = 12 - 18 = -6</span>
  c = function2();     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26412;&#22320; c = &#20840;&#23616; a + &#20840;&#23616; b = -6 + 6 = 0</span>
  cout &lt;&lt; <span class="org-string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="org-string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="org-string">" c: "</span> &lt;&lt; c &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ea97a4" class="outline-4">
<h4 id="org2ea97a4"><span class="section-number-4">2.5.2</span> <code>extern</code></h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
在多文件程序中，全局变量通常定义在一个文件中，在其他文件中使用全局变量时需要用 <code>extern</code> 进行声明。
</p>

<p>
使用 <code>extern</code> 声明全局变量时不能有初始值，因为初始值将迫使编译器为变量分配内存，使得变量在此处被定义（变量的定义只能有一次），而不是原本定义变量的位置。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>示例</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">foo.h</span>
<span class="org-type">int</span> <span class="org-variable-name">var</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">bar.h</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">var</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org68d44c9" class="outline-3">
<h3 id="org68d44c9"><span class="section-number-3">2.6</span> 静态全局变量</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">static</span> &lt;<span class="org-type">type</span>&gt; &lt;name&gt;;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd8d6202" class="outline-2">
<h2 id="orgd8d6202"><span class="section-number-2">3</span> 常量</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-org7adf6f9" class="outline-3">
<h3 id="org7adf6f9"><span class="section-number-3">3.1</span> 语法</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> &lt;<span class="org-type">type</span>&gt; &lt;name&gt; = &lt;expr&gt;;
</pre>
</div>

<p>
常量定义后不能修改，如果常量名出现在赋值表达式的左边，编译器将会报错。
</p>
</div>
</div>

<div id="outline-container-orgd4dbf23" class="outline-3">
<h3 id="orgd4dbf23"><span class="section-number-3">3.2</span> 枚举常量</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>定义</label><pre class="src src-cpp"><span class="org-keyword">enum</span> {&lt;name&gt;, &lt;name&gt;, ...};         <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#20540;&#20174; 0 &#24320;&#22987;&#20381;&#27425;&#36882;&#22686; 1</span>
<span class="org-keyword">enum</span> {&lt;name&gt;, &lt;name&gt; = &lt;<span class="org-type">int</span>&gt;, ...}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#23450;&#20540;&#20043;&#21518;&#30340;&#24120;&#37327;&#20540;&#20174;&#27492;&#25351;&#23450;&#20540;&#24320;&#22987;&#32487;&#32493;&#36882;&#22686; 1</span>
<span class="org-keyword">enum</span> {&lt;name&gt; = <span class="org-warning">'</span>&lt;<span class="org-type">char</span>&gt;<span class="org-warning">'</span>, ...};      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#20351;&#29992;&#23383;&#31526;&#32534;&#30721;&#25351;&#23450;&#20540;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>枚举类型</label><pre class="src src-cpp"><span class="org-keyword">enum</span> &lt;<span class="org-type">type_name</span>&gt; {&lt;name&gt;, &lt;name&gt;, ...}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26522;&#20030;&#31867;&#22411;</span>
<span class="org-keyword">enum</span> &lt;<span class="org-type">type_name</span>&gt; &lt;var&gt;;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;&#26522;&#20030;&#31867;&#22411;&#22768;&#26126;&#21464;&#37327;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4fa3abb" class="outline-3">
<h3 id="org4fa3abb"><span class="section-number-3">3.3</span> 符号常量</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#define</span> &lt;name&gt; &lt;expr&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb25f5e" class="outline-3">
<h3 id="orgbb25f5e"><span class="section-number-3">3.4</span> 宏</h3>
<div class="outline-text-3" id="text-3-4">
<p>
在编译为机器码之前，编译器将代码中的所有宏标识符替换为宏定义的字符序列。
</p>
</div>
</div>
</div>

<div id="outline-container-orgb7819e8" class="outline-2">
<h2 id="orgb7819e8"><span class="section-number-2">4</span> 运算符</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgce2a89e" class="outline-3">
<h3 id="orgce2a89e"><span class="section-number-3">4.1</span> 优先级</h3>
<div class="outline-text-3" id="text-4-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left"><b>结合律</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>::</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>sizeof()</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>!</code> <code>++</code> <code>--</code></td>
<td class="org-left">右向左</td>
</tr>

<tr>
<td class="org-left"><code>+</code> <code>-</code> （一元）</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>*</code> <code>&amp;</code> （指针）</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>new</code> <code>delete</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>(&lt;type&gt;)</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>*</code> <code>/</code> <code>%</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>+</code> <code>-</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>==</code> <code>!=</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>^</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&#124;</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;&amp;</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&#124;&#124;</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>? :</code></td>
<td class="org-left">右向左</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>=</code></td>
<td class="org-left">右向左</td>
</tr>

<tr>
<td class="org-left"><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>&amp;=</code> <code>^=</code> <code>&#124;=</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>,</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd9921e7" class="outline-3">
<h3 id="orgd9921e7"><span class="section-number-3">4.2</span> 数学运算符</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>整数进行除法时，结果会被截断（truncate），而不是四舍五入。</label><pre class="src src-cpp">5 / 3 <span class="org-comment-delimiter">// </span><span class="org-comment">== 1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org30d0796" class="outline-3">
<h3 id="org30d0796"><span class="section-number-3">4.3</span> 逻辑运算符</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span><code>&amp;&amp;</code> 可以替代 <code>if</code></label><pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;) &lt;statement&gt;;
(expr) &amp;&amp; &lt;statement&gt;; 
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span><code>||</code> 可以替代 <code>if ... else</code></label><pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;); <span class="org-keyword">else</span> &lt;statement&gt;;
(&lt;expr&gt;) || &lt;statement&gt;;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ad22a6" class="outline-3">
<h3 id="org6ad22a6"><span class="section-number-3">4.4</span> 一元运算符</h3>
<div class="outline-text-3" id="text-4-4">
<p>
使用一元运算符可能会导致代码移植性问题，因为 C++ 不指定数学运算中操作数的求值（evaluate）顺序，以编译器而定，如 <code>++x + x</code> ， <code>++x</code> 可能在 <code>x</code> 之前或之后求值，使结果不确定。
</p>
</div>
</div>

<div id="outline-container-orgbefd8db" class="outline-3">
<h3 id="orgbefd8db"><span class="section-number-3">4.5</span> 指针运算符</h3>
<div class="outline-text-3" id="text-4-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b><code>*</code> 指针</b></th>
<th scope="col" class="org-left"><b><code>&amp;</code> 引用</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">有自己的内存空间</td>
<td class="org-left">没有自己的内存空间（相当于其他变量的别名）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">可以不初始化</td>
<td class="org-left">必须初始化为已定义的变量（已分配的内存）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">初始化后可以再指向其他地址</td>
<td class="org-left">初始化后不能再指向其他地址</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">值可以为 <code>NULL</code></td>
<td class="org-left">值不可以为 <code>NULL</code></td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span><code>*</code> 示例</label><pre class="src src-cpp"><span class="org-type">int</span>* <span class="org-variable-name">a</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>;
<span class="org-type">int</span>* <span class="org-variable-name">b</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>;
<span class="org-type">int</span>* <span class="org-variable-name">c</span>;
*a = 1, *b = 1;
c = a, *c = 2; <span class="org-comment-delimiter">// </span><span class="org-comment">*a == 2</span>
c = b, *c = 3; <span class="org-comment-delimiter">// </span><span class="org-comment">*b == 3</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span><code>&amp;</code> 示例</label><pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">a</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">b</span> = a;
a = 1;
b = 2; <span class="org-comment-delimiter">// </span><span class="org-comment">a == 2</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>可以将引用声明为常量，称为 free-standing 引用。</label><pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">b</span> = 1;
</pre>
</div>
</div>
</div>

<div id="outline-container-org2b17391" class="outline-3">
<h3 id="org2b17391"><span class="section-number-3">4.6</span> <code>new</code></h3>
<div class="outline-text-3" id="text-4-6">
<p>
从 free store 内存空间分配内存用于指定的对象，并返回地址。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>示例</label><pre class="src src-cpp"><span class="org-type">int</span>* <span class="org-variable-name">a</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>[10];
</pre>
</div>
</div>
</div>

<div id="outline-container-org855d6f1" class="outline-3">
<h3 id="org855d6f1"><span class="section-number-3">4.7</span> <code>delete</code></h3>
<div class="outline-text-3" id="text-4-7">
<p>
清理对象，回收内存空间，防止内存泄漏。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>语法</label><pre class="src src-cpp"><span class="org-keyword">delete</span> &lt;obj&gt;;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#25910;&#21333;&#20010;&#23545;&#35937;</span>
<span class="org-keyword">delete</span> [] &lt;array&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#25910;&#23545;&#35937;&#25968;&#32452;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>示例</label><pre class="src src-cpp"><span class="org-type">char</span> *<span class="org-variable-name">foo</span>;
foo = <span class="org-keyword">new</span> <span class="org-type">char</span>[10];
<span class="org-keyword">delete</span> [] foo;
</pre>
</div>
</div>
</div>

<div id="outline-container-org50dd72b" class="outline-3">
<h3 id="org50dd72b"><span class="section-number-3">4.8</span> <code>sizeof</code></h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>获得类型（变量）的实际长度。</li>
<li>可以加或不加 <code>()</code> 。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">Empty</span> {};
<span class="org-keyword">struct</span> <span class="org-type">Base</span> { <span class="org-type">int</span> <span class="org-variable-name">a</span>; };

<span class="org-type">int</span> <span class="org-variable-name">a</span>[10];
<span class="org-type">Empty</span> <span class="org-variable-name">e</span>;
<span class="org-type">Base</span> <span class="org-variable-name">b</span>;

<span class="org-constant">std</span>::cout &lt;&lt; <span class="org-keyword">sizeof</span> a                 &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">40</span>
          &lt;&lt; (<span class="org-keyword">sizeof</span> a) / (<span class="org-keyword">sizeof</span> *a) &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">10</span>
          &lt;&lt; <span class="org-keyword">sizeof</span>(e)                &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">1</span>
          &lt;&lt; <span class="org-keyword">sizeof</span> b                 &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">4</span>
          &lt;&lt; <span class="org-keyword">sizeof</span> &amp;b                &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">8</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd14707" class="outline-3">
<h3 id="orgdd14707"><span class="section-number-3">4.9</span> <code>&gt;&gt;</code></h3>
<div class="outline-text-3" id="text-4-9">
<p>
<code>&gt;&gt;</code> recognizes operands, such as input_buffer, that are pointers to character arrays. <code>&gt;&gt;</code> reads a string from the input stream up to the first whitespace character ― space, tab, or carriage return, then deposits that string into the array identified by the pointer.
</p>
</div>
</div>

<div id="outline-container-org1501a8c" class="outline-3">
<h3 id="org1501a8c"><span class="section-number-3">4.10</span> 运算符重载</h3>
<div class="outline-text-3" id="text-4-10">
<div class="org-src-container">
<pre class="src src-cpp">&lt;type&gt; <span class="org-keyword">operator</span> &lt;<span class="org-type">symbol</span>&gt; (&lt;type&gt; &lt;param&gt;, ...) {
}
</pre>
</div>
</div>

<div id="outline-container-org043e114" class="outline-4">
<h4 id="org043e114"><span class="section-number-4">4.10.1</span> 重载 <code>&lt;&lt;</code></h4>
<div class="outline-text-4" id="text-4-10-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>:
    <span class="org-keyword">friend</span> <span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span> (<span class="org-type">ostream</span>&amp; <span class="org-variable-name">out</span>, <span class="org-type">Foo</span>&amp; <span class="org-variable-name">f</span>) {
      out &lt;&lt; f.bar;
      <span class="org-keyword">return</span> out;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org166ce3e" class="outline-4">
<h4 id="org166ce3e"><span class="section-number-4">4.10.2</span> 重载 <code>&lt;</code></h4>
<div class="outline-text-4" id="text-4-10-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;</span> (<span class="org-keyword">const</span> <span class="org-type">Foo</span> <span class="org-variable-name">f</span>) {
      <span class="org-keyword">return</span> bar &lt; f.bar;
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge888522" class="outline-2">
<h2 id="orge888522"><span class="section-number-2">5</span> 指针</h2>
<div class="outline-text-2" id="text-5">
<p>
指针的大小取决于编译器。
</p>
</div>

<div id="outline-container-org6c2f0ec" class="outline-3">
<h3 id="org6c2f0ec"><span class="section-number-3">5.1</span> 内存</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Ordinarily, when a global variable is defined, C++ compiler allocates the memory required to hold an object corresponding to the variable's type.
</p>

<p>
When using pointer, C++ allocates only a small amount of memory for a pointer at compile time, deferring until run time the allocation of memory for an object. Run-time allocation reduces the memory consumed by program. 
</p>


<div class="figure">
<p><img src="../images/c++/03.png" alt="03.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8a79ab6" class="outline-3">
<h3 id="org8a79ab6"><span class="section-number-3">5.2</span> 运算符</h3>
<div class="outline-text-3" id="text-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>*</code></th>
<th scope="col" class="org-left">Dereferencing operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>&amp;</code></td>
<td class="org-left">Address-of operator，C++ 中较少使用</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>-&gt;</code></td>
<td class="org-left">Class-pointer operator，等价于 <code>(*&lt;pointer&gt;).</code></td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left"><b>值</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>&lt;pointer&gt;</code></td>
<td class="org-left">地址</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>*&lt;pointer&gt;</code></td>
<td class="org-left">对象</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;&lt;var&gt;</code></td>
<td class="org-left">地址</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2d93b80" class="outline-3">
<h3 id="org2d93b80"><span class="section-number-3">5.3</span> 语法</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>定义</label><pre class="src src-cpp">&lt;type&gt; *&lt;pointer&gt;;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>赋值</label><pre class="src src-cpp">&lt;pointer&gt; = <span class="org-keyword">new</span> &lt;type&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">new &#34920;&#36798;&#24335;&#36820;&#22238;&#30340;&#26159;&#20998;&#37197;&#30340;&#22320;&#22336;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#65306;</span>
&lt;var&gt; = <span class="org-keyword">new</span> &lt;type&gt;;
&lt;pointer&gt; = &amp;&lt;var&gt;;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>类对象</label><pre class="src src-cpp">&lt;Class&gt; *&lt;pointer&gt;;
&lt;pointer&gt; = <span class="org-keyword">new</span> &lt;Class&gt;;

&lt;pointer&gt;-&gt;&lt;var&gt; = ... ;
&lt;pointer&gt;-&gt;&lt;function&gt;();
<span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#65306;</span>
(*&lt;pointer&gt;).&lt;var&gt; = ... ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#25104;&#21592;&#36816;&#31639;&#31526; . &#30340;&#20248;&#20808;&#32423;&#39640;&#20110;&#25351;&#38024;&#36816;&#31639;&#31526; *</span>
(*&lt;pointer&gt;).&lt;function&gt;();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf6d31b1" class="outline-3">
<h3 id="orgf6d31b1"><span class="section-number-3">5.4</span> 指针数组</h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>定义</label><pre class="src src-cpp">&lt;type&gt; *&lt;pointer&gt;[&lt;n&gt;]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#36816;&#31639;&#31526; * &#20248;&#20808;&#32423;&#39640;&#20110; []&#65292;&#22240;&#27492;&#23450;&#20041;&#30340;&#26159; n &#20010;&#25351;&#38024;&#30340;&#25968;&#32452;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>类对象</label><pre class="src src-cpp">&lt;Class&gt; *&lt;pointer&gt;[&lt;n&gt;];
&lt;pointer&gt;[&lt;idx&gt;] = <span class="org-keyword">new</span> &lt;Class&gt;;

(*&lt;pointer&gt;[&lt;idx&gt;]).&lt;var&gt; = ... ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#25104;&#21592;&#36816;&#31639;&#31526; . &#30340;&#20248;&#20808;&#32423;&#39640;&#20110;&#25351;&#38024;&#36816;&#31639;&#31526; *</span>
(*&lt;pointer&gt;[&lt;idx&gt;]).&lt;function&gt;();
<span class="org-comment-delimiter">// </span><span class="org-comment">&#25110;</span>
&lt;pointer&gt;[&lt;idx&gt;]-&gt;&lt;var&gt; = ... ;
&lt;pointer&gt;[&lt;idx&gt;]-&gt;&lt;function&gt;();
</pre>
</div>

<p>
定义类对象指针数组中的指针，可以指向某类或其子类的对象。因此通过类对象指针数组，可以解决「普通数组要求其中的元素数据类型完全一致」的问题。
</p>
</div>
</div>
</div>

<div id="outline-container-orgdb01da5" class="outline-2">
<h2 id="orgdb01da5"><span class="section-number-2">6</span> 语句</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgeb15b6a" class="outline-3">
<h3 id="orgeb15b6a"><span class="section-number-3">6.1</span> <code>for</code></h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-orgd4ad3e2" class="outline-4">
<h4 id="orgd4ad3e2"><span class="section-number-4">6.1.1</span> 一般循环</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">for</span> (&lt;init&gt;; &lt;expr&gt;; &lt;incr&gt;) {
}
</pre>
</div>

<p>
当 <code>&lt;expr&gt;</code> 的值为 <code>0</code> 或 <code>NULL</code> 时，循环中止。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>循环体的内容可以合并到条件中</label><pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">counter</span>, <span class="org-variable-name">result</span> = 1;
<span class="org-keyword">for</span> (counter = n; counter; --counter) {
  result *= 2;
}

<span class="org-type">int</span> <span class="org-variable-name">counter</span>, <span class="org-variable-name">result</span>;
<span class="org-keyword">for</span> (counter = n, result = 1;
     counter;
     --counter, result *= 2);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd5b3fb" class="outline-4">
<h4 id="orgbd5b3fb"><span class="section-number-4">6.1.2</span> 迭代循环</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
从 C++ 11 开始 <code>for</code> 支持迭代（range-based）循环。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">for</span> (&lt;type&gt; &lt;elem&gt; : &lt;range&gt;) {
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>示例</label><pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">nums</span>[] = {1, 2, 3};
<span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">num</span> : nums) {
  cout &lt;&lt; num &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org008173b" class="outline-3">
<h3 id="org008173b"><span class="section-number-3">6.2</span> <code>if</code></h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;) {
  ...
} <span class="org-keyword">else</span> <span class="org-keyword">if</span> (&lt;expr&gt;) {
  ...
} <span class="org-keyword">else</span> {
  ...
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga5ea377" class="outline-3">
<h3 id="orga5ea377"><span class="section-number-3">6.3</span> <code>switch</code></h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">switch</span> (&lt;expr&gt;) {
  <span class="org-keyword">case</span> &lt;<span class="org-type">int</span>&gt;:
    ...;
    <span class="org-keyword">break</span>;
  <span class="org-keyword">default</span>:
    ...;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0c9c72d" class="outline-3">
<h3 id="org0c9c72d"><span class="section-number-3">6.4</span> <code>try</code> <code>catch</code></h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">try</span> {
    ...
} <span class="org-keyword">catch</span> (<span class="org-type">exception</span>&amp; <span class="org-variable-name">e</span>) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6248e2" class="outline-3">
<h3 id="orgc6248e2"><span class="section-number-3">6.5</span> <code>while</code></h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">while</span> (&lt;expr&gt;) {
  ...
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">do</span> {
  ...
} <span class="org-keyword">while</span> (&lt;expr&gt;);
</pre>
</div>
</div>
</div>

<div id="outline-container-org333e98f" class="outline-3">
<h3 id="org333e98f"><span class="section-number-3">6.6</span> 注释</h3>
<div class="outline-text-3" id="text-6-6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Short comment</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment">Long comment ...</span>
<span class="org-comment">that just goes on ...</span>
<span class="org-comment">and on ...</span>
<span class="org-comment">*/</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org18adeef" class="outline-2">
<h2 id="org18adeef"><span class="section-number-2">7</span> 函数</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgde3cf71" class="outline-3">
<h3 id="orgde3cf71"><span class="section-number-3">7.1</span> 定义</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>定义</label><pre class="src src-cpp">&lt;type&gt; &lt;name&gt; (&lt;type&gt; &lt;param&gt;, ...) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Declarations</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Statements</span>
}
</pre>
</div>

<p>
函数只可以被定义一次，但可以声明多次（通过函数原型）。
</p>

<p>
编译器通常要求函数定义必须出现在函数调用之前。
</p>

<p>
C++ 允许同名函数，但同名函数的参数类型必须不同。被重复使用的函数名称为被重载（overload）。调用被重载的函数时，编译器通过传入参数的类型进行匹配，确定实际调用的函数。
</p>
</div>
</div>

<div id="outline-container-org169ec23" class="outline-3">
<h3 id="org169ec23"><span class="section-number-3">7.2</span> 内存</h3>
<div class="outline-text-3" id="text-7-2">
<p>
C++ is a call-by-value language. When a function is called, copies of the value of the arguments become the value of the parameters. C++ reserves a chunk of memory for each parameter every time the function is called. Therefore a local variable in a function doesn't affect the values of variable with the same name outside the function.
</p>


<div class="figure">
<p><img src="../images/c++/05.png" alt="05.png" />
</p>
</div>

<hr />

<p>
The memory set aside for each function's call-by-value parameters and local variables is set aside only temporarily. When a function is called, memory chunks are pushed onto the end of an area of memory called the stack; after a function returns, the memory in those chunks is overwritten as soon as subsequent function calls cause new memory chunks to be pushed onto the stack.
</p>

<p>
When a function is to return the value of a call-by-value parameter or of a local variable, the C++ compiler arranges, by default, for such values to be copied before they are lost.
</p>


<div class="figure">
<p><img src="../images/c++/06.png" alt="06.png" />
</p>
</div>

<p>
Some functions involve a pass-through object: an object that is handed to the function via a call-by-reference parameter, without copying, and is to be returned as the function's value, also without copying.
</p>
</div>
</div>

<div id="outline-container-org6cf2153" class="outline-3">
<h3 id="org6cf2153"><span class="section-number-3">7.3</span> 参数</h3>
<div class="outline-text-3" id="text-7-3">
</div><div id="outline-container-orge96fe8c" class="outline-4">
<h4 id="orge96fe8c"><span class="section-number-4">7.3.1</span> 类型</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
参数的类型默认为 <code>int</code> 。
</p>
</div>
</div>

<div id="outline-container-orgd89af25" class="outline-4">
<h4 id="orgd89af25"><span class="section-number-4">7.3.2</span> 传值</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
<a id="orgdee4c6a"></a>
参数为对象时，传值会出现的问题（excess-reclamation bug）：C++ 通过一个<a href="#orgd8b6afa">复制构造函数（copy constructor）</a>复制对象，C++ 编译器会实现一个默认的复制构造函数，逻辑是复制对象所有的成员变量。如果一个成员变量是指针类型，则指针被复制，但指针所指的变量不被复制，即两个指针（原对象的指针和复制对象的指针）指向同一块内存。当复制对象的内存被回收时（即传值函数返回时），对象的析构函数可能同时会回收（通过 <code>delete</code> ）指针所指变量的内存，这导致原对象的指针指向空（在一段时间内该指针还可以返回数据，直到这部分内存被重新分配并覆盖）。
</p>


<div class="figure">
<p><img src="../images/c++/07.png" alt="07.png" />
</p>
</div>

<p>
可能的解决方法：
</p>
<ul class="org-ul">
<li>自定义复制构造函数，在复制对象时，连指针变量指向的变量也进行复制</li>
<li>在对象作为函数参数时，使用传引用的方式</li>
</ul>

<p>
通常采用的是「传引用」的解决方法，因为编程的一个理念（philosophy）是：对象一般代表的是真实世界中的独立个体，对象的创建、复制、销毁应该模仿真实世界中的模式，即不应该在对象作为参数进行函数调用前后，复制和销毁对象。
</p>

<p>
为避免对象被作为传值参数（被复制），可以将类的复制构造函数声明为 <code>private</code> ，当类对象以传值方式作为函数参数时，编译会报错。、
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>可以只在基类中声明为原型：</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>: <span class="org-function-name">Foo</span>(<span class="org-type">Foo</span>&amp;);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org287be39" class="outline-4">
<h4 id="org287be39"><span class="section-number-4">7.3.3</span> 传引用</h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
参数默认为传值（call-by-value），需要传引用（call-by-reference）时，使用 <code>&amp;</code> 声明。需要传引用的场合：
</p>

<ul class="org-ul">
<li>大的对象进行复制速度较慢。</li>
<li>函数需要对传入参数本身进行修改。</li>
<li>参数类型是基类，而传入值是多态的子类对象，长度可能不同。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>示例</label><pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span>&amp; <span class="org-variable-name">bar</span>) {}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>示例：传数组引用</label><pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">bar</span>[]) {}
<span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">bar</span>[10]) {}
<span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span>* <span class="org-variable-name">bar</span>) {}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f18215" class="outline-4">
<h4 id="org5f18215"><span class="section-number-4">7.3.4</span> 默认值</h4>
<div class="outline-text-4" id="text-7-3-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>带有默认值的参数必须在最右：</label><pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span> = 1) {}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org79dd2d7" class="outline-3">
<h3 id="org79dd2d7"><span class="section-number-3">7.4</span> 返回值</h3>
<div class="outline-text-3" id="text-7-4">
<p>
只有返回值类型为 <code>void</code> 的函数可以没有 <code>return</code> 语句。一些程序员认为正确的做法是使用空的 <code>return</code> 语句。
</p>

<hr />

<p>
函数返回值类型后加 <code>&amp;</code> ，表示函数返回值时不进行复制，而是直接返回。
</p>

<div class="org-src-container">
<pre class="src src-cpp">&lt;type&gt;&amp; &lt;function&gt;(...) {
}
</pre>
</div>

<p>
只有在参数是传递引用时，返回值才可以是引用，即传入和返回的是同一个变量的引用，比如运算符重载。
</p>
</div>
</div>

<div id="outline-container-orge0d3d30" class="outline-3">
<h3 id="orge0d3d30"><span class="section-number-3">7.5</span> 原型</h3>
<div class="outline-text-3" id="text-7-5">
<p>
一个函数声明，没有参数名和函数体，只有参数类型和返回类型。通过原型，编译器可以为此函数的调用做准备（如何分配内存），使得其他函数可以在未定义函数体的情况下对其进行调用。
</p>

<ul class="org-ul">
<li>普通函数原型是为了解决「相互调用的函数定义顺序」的问题。</li>
<li>类函数原型是为了将类函数的定义移动到类定义之外。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>示例：斐波那契数列（兔子繁殖问题）</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Function prototype</span>
<span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Function definitions requiring function prototype:</span>
<span class="org-type">int</span> <span class="org-function-name">previous_month</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) { <span class="org-keyword">return</span> rabbits (n - 1); }
<span class="org-type">int</span> <span class="org-function-name">penultimate_month</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) { <span class="org-keyword">return</span> rabbits (n - 2); }

<span class="org-comment-delimiter">// </span><span class="org-comment">Function definition</span>
<span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">if</span> (n == 0 || n == 1)
    <span class="org-keyword">return</span> 1;
  <span class="org-keyword">else</span> <span class="org-keyword">return</span> previous_month (n) + penultimate_month (n);
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>原型可以加参数名</label><pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e27635" class="outline-3">
<h3 id="org3e27635"><span class="section-number-3">7.6</span> 模板</h3>
<div class="outline-text-3" id="text-7-6">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">t</span>&gt; <span class="org-type">void</span> <span class="org-function-name">print_vector</span>(<span class="org-type">vector</span>&lt;<span class="org-type">t</span>&gt; <span class="org-variable-name">v</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">t</span> <span class="org-variable-name">elem</span>: v)
    cout &lt;&lt; elem &lt;&lt; endl;
  <span class="org-keyword">return</span>;
}

print_vector&lt;<span class="org-type">int</span>&gt;(int_vector);
print_vector&lt;stirng&gt;(string_vector);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org767192a" class="outline-2">
<h2 id="org767192a"><span class="section-number-2">8</span> OO</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-org44f63ad" class="outline-3">
<h3 id="org44f63ad"><span class="section-number-3">8.1</span> 类</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-orgb7d044c" class="outline-4">
<h4 id="orgb7d044c"><span class="section-number-4">8.1.1</span> 定义</h4>
<div class="outline-text-4" id="text-8-1-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#23450;&#20041;&#32467;&#26463;&#26377; ;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org94025af" class="outline-4">
<h4 id="org94025af"><span class="section-number-4">8.1.2</span> 实例化</h4>
<div class="outline-text-4" id="text-8-1-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>作为数据类型声明变量</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;</span>
<span class="org-type">Foo</span> <span class="org-variable-name">foo</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#20363;&#21270;</span>
<span class="org-type">Foo</span> <span class="org-variable-name">foo</span>(1);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>类定义的同时声明变量</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {} <span class="org-type">foo1</span> <span class="org-variable-name">foo2</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org348de23" class="outline-4">
<h4 id="org348de23"><span class="section-number-4">8.1.3</span> 继承</h4>
<div class="outline-text-4" id="text-8-1-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> : <span class="org-keyword">public</span> <span class="org-type">Bar</span>, <span class="org-keyword">protected</span> <span class="org-type">Qux</span> {};
</pre>
</div>

<ul class="org-ul">
<li>支持多继承。</li>
<li>基类必须在子类之前定义。</li>
</ul>
</div>
</div>

<div id="outline-container-org445224b" class="outline-4">
<h4 id="org445224b"><span class="section-number-4">8.1.4</span> 示例</h4>
<div class="outline-text-4" id="text-8-1-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Class</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>;
<span class="org-keyword">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">va</span>, <span class="org-type">int</span> <span class="org-variable-name">vb</span>) {
        a = va;
        b = vb;
        <span class="org-keyword">return</span>;
    }
    <span class="org-type">void</span> <span class="org-function-name">bar</span>();
}

<span class="org-type">void</span> <span class="org-constant">Class</span>::<span class="org-function-name">bar</span>() {
    <span class="org-keyword">return</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Class</span> <span class="org-variable-name">obj</span>;
    obj.foo(1, 2);
    obj.bar();
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org824adb0" class="outline-3">
<h3 id="org824adb0"><span class="section-number-3">8.2</span> 抽象类</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>抽象类不可被实例化。</li>
<li>通过定义完全虚拟函数来实现抽象类，最简单的方式是将析构函数定义为完全虚拟。</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
<span class="org-keyword">public</span>:
    <span class="org-function-name">Foo</span>() {}
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Foo</span>() = 0;
};
<span class="org-constant">Foo</span>::~<span class="org-function-name">Foo</span>() {}
</pre>
</div>
</div>
</div>

<div id="outline-container-org398dd43" class="outline-3">
<h3 id="org398dd43"><span class="section-number-3">8.3</span> 模板</h3>
<div class="outline-text-3" id="text-8-3">
<p>
模板是一种代码重用方式，使同一个类可以用于不同的数据类型。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Type</span>&gt; <span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-type">Type</span> <span class="org-variable-name">t</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Foo</span>(<span class="org-type">Type</span> <span class="org-variable-name">v</span>) : t(v) {}
  <span class="org-type">Type</span> <span class="org-function-name">add</span>(<span class="org-type">Type</span> <span class="org-variable-name">v</span>) { <span class="org-keyword">return</span> t + v; }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization</span>
<span class="org-keyword">template</span> &lt;&gt; <span class="org-keyword">class</span> <span class="org-type">Foo</span> &lt;<span class="org-type">string</span>&gt; {
  <span class="org-type">string</span> <span class="org-variable-name">s</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Foo</span>(<span class="org-type">string</span> <span class="org-variable-name">v</span>) : s(v) {}
  <span class="org-type">string</span> <span class="org-function-name">add</span>(<span class="org-type">string</span> <span class="org-variable-name">v</span>) { <span class="org-keyword">return</span> s + v; }
};

<span class="org-type">Foo</span>&lt;<span class="org-type">double</span>&gt; <span class="org-function-name">foo1</span>(double1);
cout &lt;&lt; foo1.add(double2) &lt;&lt; endl;
<span class="org-type">Foo</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">foo2</span>(int1);
cout &lt;&lt; foo2.add(int2) &lt;&lt; endl;
<span class="org-type">Foo</span>&lt;<span class="org-type">string</span>&gt; <span class="org-function-name">foo3</span>(string1);
cout &lt;&lt; foo3.add(string2) &lt;&lt; endl;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgec1aae0" class="outline-3">
<h3 id="orgec1aae0"><span class="section-number-3">8.4</span> <code>friend</code></h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">ClassA</span>&gt; {
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> &lt;<span class="org-type">ClassB</span>&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126; ClassB &#20026; ClassA &#30340; friend</span>
  <span class="org-keyword">private</span>:
    &lt;type&gt; &lt;var&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">ClassA &#30340;&#25152;&#26377;&#25104;&#21592;&#21464;&#37327;&#21644;&#20989;&#25968;&#23545;&#20110; ClassB &#37117;&#26159; public &#30340;</span>
    &lt;<span class="org-type">ClassA</span>&gt;() {
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9afd83" class="outline-3">
<h3 id="orgf9afd83"><span class="section-number-3">8.5</span> 可见性</h3>
<div class="outline-text-3" id="text-8-5">
<p>
成员变量、函数默认为 <code>private</code> 。
</p>

<hr />

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">
<caption class="t-above"><span class="table-number">Table 1:</span> 继承时通过声明基类的可见性，批量改变基类中成员的可见性：</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>protected</code></th>
<th scope="col" class="org-left">基类中的 <code>public</code> 成员在子类中为 <code>protected</code> 。</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left"><code>protected</code> 和 <code>private</code> 成员不变。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>private</code></td>
<td class="org-left">基类中的 <code>public</code> 和 <code>protected</code> 成员在子类中为 <code>private</code> 。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>private</code> 成员不变。</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">First</span> {
  <span class="org-keyword">public</span>: <span class="org-type">double</span> <span class="org-variable-name">var1</span>, <span class="org-variable-name">var2</span>;
}

<span class="org-keyword">class</span> <span class="org-type">Second</span> : <span class="org-keyword">protected</span> <span class="org-type">First</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312; Second &#20013; var1 &#21644; var2 &#20026; protected</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#35265;&#24615;&#32487;&#32493;&#20256;&#36882;</span>
<span class="org-keyword">class</span> <span class="org-type">Third</span> : <span class="org-keyword">public</span> <span class="org-type">Second</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312; Third &#20013; var1 &#21644; var2 &#20381;&#28982;&#20026; protected</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org603606a" class="outline-3">
<h3 id="org603606a"><span class="section-number-3">8.6</span> 成员变量</h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    &lt;visib&gt;: &lt;type&gt; &lt;var&gt;;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span>访问对象的成员变量</label><pre class="src src-cpp">&lt;Class&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;var&gt; = &lt;value&gt;;
</pre>
</div>
</div>

<div id="outline-container-orgd776ceb" class="outline-4">
<h4 id="orgd776ceb"><span class="section-number-4">8.6.1</span> 静态成员变量</h4>
<div class="outline-text-4" id="text-8-6-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">bar</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;</span>
}
<span class="org-type">int</span> <span class="org-constant">Foo</span>::<span class="org-variable-name">bar</span> = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#65292;&#38656;&#35201;&#22768;&#26126;&#31867;&#22411;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc018a42" class="outline-3">
<h3 id="orgc018a42"><span class="section-number-3">8.7</span> 成员函数</h3>
<div class="outline-text-3" id="text-8-7">
</div><div id="outline-container-orgd3ff439" class="outline-4">
<h4 id="orgd3ff439"><span class="section-number-4">8.7.1</span> 定义</h4>
<div class="outline-text-4" id="text-8-7-1">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;type&gt; &lt;var&gt;, &lt;var&gt;;
            &lt;type&gt; &lt;function&gt;() {
                <span class="org-keyword">return</span> &lt;var&gt;;
            }
};
</pre>
</div>

<p>
Each member function has one special argument:
</p>
<ul class="org-ul">
<li>the value is a class object that belongs to the same class as does the member function</li>
<li>it does not appear in parentheses, instead, it is joined, via the class-member operator <code>.</code> to the name of the member function</li>
</ul>
</div>
</div>

<div id="outline-container-orgf65b5c5" class="outline-4">
<h4 id="orgf65b5c5"><span class="section-number-4">8.7.2</span> 执行</h4>
<div class="outline-text-4" id="text-8-7-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
&lt;<span class="org-type">Class</span>&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;function&gt;();
&lt;obj&gt;.&lt;Parent&gt;::&lt;function&gt;(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5e0a0a2" class="outline-4">
<h4 id="org5e0a0a2"><span class="section-number-4">8.7.3</span> 继承</h4>
<div class="outline-text-4" id="text-8-7-3">
<p>
继承关系中，子类与基类有同名函数时，除非指定，否则默认调用子类中定义的函数。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Parent</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
<span class="org-keyword">class</span> &lt;<span class="org-type">Child</span>&gt; : <span class="org-keyword">public</span> &lt;<span class="org-type">Parent</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
&lt;<span class="org-type">Child</span>&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;function&gt;();           <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#23376;&#31867;&#30340;&#20989;&#25968;</span>
&lt;obj&gt;.&lt;<span class="org-type">Parent</span>&gt;::&lt;function&gt;(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#30340;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1afa315" class="outline-4">
<h4 id="org1afa315"><span class="section-number-4">8.7.4</span> <code>this</code></h4>
<div class="outline-text-4" id="text-8-7-4">
<p>
<code>this</code> 用于在一个成员函数中（使用当前的对象）调用另一个成员函数。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span>语法</label><pre class="src src-cpp"><span class="org-function-name">foo</span>() {
  cout &lt;&lt; (*<span class="org-keyword">this</span>).bar();
  cout &lt;&lt; <span class="org-keyword">this</span>-&gt;bar();
  cout &lt;&lt; bar();        <span class="org-comment-delimiter">// </span><span class="org-comment">&#38544;&#24335;&#20889;&#27861;&#65292;this &#21487;&#20197;&#30465;&#30053;</span>
}
<span class="org-function-name">bar</span>() {
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgee5b019" class="outline-3">
<h3 id="orgee5b019"><span class="section-number-3">8.8</span> 虚拟函数</h3>
<div class="outline-text-3" id="text-8-8">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 45: </span>C++ 在编译时就决定将调用的成员函数，称为静态绑定（static binding），使得子类无法实现多态。</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a student."</span>; }
};

<span class="org-type">Student</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a person.</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 46: </span>虚拟成员函数（virtual member function）使得程序在运行时，而不是编译时，选择将调用的函数。</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;&#20013;&#19981;&#38656;&#35201;&#37325;&#26032;&#22768;&#26126;&#20026; virtual &#65292;&#20294;&#36890;&#24120;&#20173;&#26174;&#24335;&#22768;&#26126;</span>
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a student."</span>; }
};

<span class="org-type">Student</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>
</pre>
</div>
</div>

<div id="outline-container-orgd22f3ab" class="outline-4">
<h4 id="orgd22f3ab"><span class="section-number-4">8.8.1</span> 完全虚拟函数</h4>
<div class="outline-text-4" id="text-8-8-1">
<p>
当某个子类未定义虚拟成员函数，以覆盖基类的定义时，基类的虚拟成员函数将被调用。完全虚拟函数（pure virtual function）可以避免基类的虚拟成员函数被调用。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">bar</span>() = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#20840;&#34394;&#25311;</span>
}
</pre>
</div>

<ul class="org-ul">
<li>子类未实现完全虚拟函数时，编译会报错。</li>
<li>定义了完全虚拟函数的类为抽象类，无法实例化。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3106205" class="outline-3">
<h3 id="org3106205"><span class="section-number-3">8.9</span> 构造函数</h3>
<div class="outline-text-3" id="text-8-9">
<ul class="org-ul">
<li>与类同名。</li>
<li>没有返回值类型。</li>
<li>默认构造函数没有参数。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span>定义</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Foo</span>() {}              <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;</span>
    <span class="org-function-name">Foo</span>(): bar(1) {}      <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#21021;&#22987;&#21270;&#31616;&#20889;</span>
    <span class="org-function-name">Foo</span>(<span class="org-type">int</span> <span class="org-variable-name">v</span>) {}         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;</span>
    <span class="org-function-name">Foo</span>(<span class="org-type">int</span> <span class="org-variable-name">v</span>): <span class="org-function-name">bar</span>(v) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;&#21021;&#22987;&#21270;&#31616;&#20889;</span>
};

<span class="org-type">Foo</span> <span class="org-variable-name">foo</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
<span class="org-type">Foo</span> <span class="org-function-name">foo</span>(v); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#33258;&#23450;&#20041;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span>调用基类构造函数</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
<span class="org-keyword">protected</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">string</span> <span class="org-variable-name">firstname</span>;
    <span class="org-type">string</span> <span class="org-variable-name">lastname</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Person</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>, <span class="org-type">string</span> <span class="org-variable-name">fn</span>, <span class="org-type">string</span> <span class="org-variable-name">ln</span>) : id(id), firstname(fn), lastname(ln) {}
};

<span class="org-keyword">class</span> <span class="org-type">Student</span>: <span class="org-keyword">public</span> <span class="org-type">Person</span> {
<span class="org-keyword">protected</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">scores</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Student</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>, <span class="org-type">string</span> <span class="org-variable-name">fn</span>, <span class="org-type">string</span> <span class="org-variable-name">ln</span>, <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">scores</span>): <span class="org-function-name">Person</span>(id, fn, ln), <span class="org-function-name">scores</span>(scores) {}
};
</pre>
</div>
</div>

<div id="outline-container-org8a40443" class="outline-4">
<h4 id="org8a40443"><span class="section-number-4">8.9.1</span> 基类构造函数</h4>
<div class="outline-text-4" id="text-8-9-1">
<p>
实例化子类时，基类的构造函数先于子类的被执行。
</p>

<div class="org-src-container">
<pre class="src src-cpp">&lt;ChildClass&gt;() : &lt;ParentClass&gt;(&lt;value&gt;, ...)
                 [, &lt;ParentClass&gt;(&lt;value&gt;, ...)]
                 {}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span>示例</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22522;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box</span> : <span class="org-keyword">public</span> <span class="org-type">container</span> {
  <span class="org-keyword">public</span>: 
    <span class="org-type">double</span> <span class="org-variable-name">height</span>, <span class="org-variable-name">width</span>, <span class="org-variable-name">length</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box</span>() {}
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box</span>(<span class="org-type">double</span> <span class="org-variable-name">h</span>, <span class="org-type">double</span> <span class="org-variable-name">w</span>, <span class="org-type">double</span> <span class="org-variable-name">l</span>) {
      height = h; width = w; length = l;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box_car</span> : <span class="org-keyword">public</span> <span class="org-type">railroad_car</span>, <span class="org-keyword">public</span> <span class="org-type">box</span> {
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box_car</span>() : box(10.5, 9.5, 40.0) {}
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22522;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">railroad_car</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">char</span> *<span class="org-variable-name">serial_number</span>;
    <span class="org-function-name">railroad_car</span>() {}
    <span class="org-function-name">railroad_car</span>(<span class="org-type">char</span> *<span class="org-variable-name">input_buffer</span>) {
      serial_number = <span class="org-keyword">new</span> <span class="org-type">char</span>[strlen(input_buffer) + 1];
      strcpy(serial_number, input_buffer);
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box_car</span> : <span class="org-keyword">public</span> <span class="org-type">railroad_car</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">box_car</span>() {}
    <span class="org-function-name">box_car</span>(<span class="org-type">char</span> *<span class="org-variable-name">input_buffer</span>) : railroad_car(input_buffer) {}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ce3e82" class="outline-4">
<h4 id="org4ce3e82"><span class="section-number-4">8.9.2</span> 复制构造函数</h4>
<div class="outline-text-4" id="text-8-9-2">
<p>
<a id="orgd8b6afa"></a>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span>示例</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>: 
    <span class="org-function-name">Foo</span>(<span class="org-type">Foo</span>&amp; <span class="org-variable-name">f</span>) { bar = f.bar; }
}
</pre>
</div>

<p>
将复制构造函数声明为私有，可以避免 <a href="#orgdee4c6a">excess-reclamation bug</a>。
</p>
</div>
</div>
</div>

<div id="outline-container-org10c771b" class="outline-3">
<h3 id="org10c771b"><span class="section-number-3">8.10</span> 析构函数</h3>
<div class="outline-text-3" id="text-8-10">
<ul class="org-ul">
<li>名称为 <code>~</code> 前缀加类名。</li>
<li>在类对象的内存被回收时调用：
<ul class="org-ul">
<li>使用 <code>delete</code> 运算符时。</li>
<li>作为传值参数的函数返回时。</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgb7489b3" class="outline-4">
<h4 id="orgb7489b3"><span class="section-number-4">8.10.1</span> 虚拟析构函数</h4>
<div class="outline-text-4" id="text-8-10-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 51: </span>当使用多态，使用基类指针声明子类对象时，子类的析构函数无法被调用：</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Person</span>() { cout &lt;&lt; <span class="org-string">"Deleting person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Student</span>() { cout &lt;&lt; <span class="org-string">"Deleting student."</span>; }
};

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
<span class="org-keyword">delete</span> p; <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting person.</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span>将基类中的析构函数声明为 <code>virtual</code> ，可以使基类和子类的析构函数都被调用：</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">Person</span>() { cout &lt;&lt; <span class="org-string">"Deleting person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Student</span>() { cout &lt;&lt; <span class="org-string">"Deleting student."</span>; }
};

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
<span class="org-keyword">delete</span> p; <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting student.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting person.</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org966f8a6" class="outline-3">
<h3 id="org966f8a6"><span class="section-number-3">8.11</span> 函数原型</h3>
<div class="outline-text-3" id="text-8-11">
<dl class="org-dl">
<dt>Function prototype</dt><dd>A preview of a member function definition within the class definition. <br />
Similar to a function definition but without a body. <br />
The function can be defined elsewhere, outside of the class definition.</dd>
</dl>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span>声明</label><pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;type&gt; &lt;function&gt;(&lt;type&gt;);
};
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span>定义</label><pre class="src src-cpp">&lt;type&gt; &lt;Class&gt;::&lt;function&gt;(&lt;type&gt; &lt;param&gt;) { <span class="org-comment-delimiter">// </span><span class="org-comment">:: are called the class-scope operator</span>
    ...
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcf8e838" class="outline-2">
<h2 id="orgcf8e838"><span class="section-number-2">9</span> 程序</h2>
<div class="outline-text-2" id="text-9">
<p>
A good program
</p>
<ul class="org-ul">
<li>is decomposed logically into functions where any one function does one and only one task</li>
<li>has a main program that reads like an outline of what the program will do</li>
<li>has descriptive function, constant and variable names</li>
<li>uses constants to avoid any "magic" numbers in the program</li>
<li>has a friendly user interface</li>
</ul>
</div>

<div id="outline-container-org7e14864" class="outline-3">
<h3 id="org7e14864"><span class="section-number-3">9.1</span> 头文件</h3>
<div class="outline-text-3" id="text-9-1">
<p>
头文件向源码文件输出服务，即 <code>.cpp</code> 文件中 <code>#include</code> 头文件。
</p>

<p>
头文件包含：
</p>
<ul class="org-ul">
<li>类定义（成员变量、成员函数原型）</li>
<li>全局变量声明</li>
<li>普通（全局）函数原型</li>
</ul>

<p>
头文件只包含声明，不包含定义（内存分配操作），因为头文件可能被多个文件加载，而变量和函数定义只能有一次。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span>示例：=class.h=</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Description: ...</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">myConst</span> = 1;

<span class="org-keyword">class</span> <span class="org-type">Class</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Class</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor</span>
    ~<span class="org-function-name">Class</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor</span>

    <span class="org-type">void</span> <span class="org-function-name">set_attr</span>(<span class="org-type">string</span> <span class="org-variable-name">attr</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">Mutator</span>
    <span class="org-type">string</span> <span class="org-function-name">get_attr</span>();          <span class="org-comment-delimiter">// </span><span class="org-comment">Accessor</span>

    <span class="org-type">void</span> <span class="org-function-name">foo</span>();

  <span class="org-keyword">private</span>:
    <span class="org-type">string</span> <span class="org-variable-name">attr</span>;
}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#23614;&#38656;&#35201; ;</span>
</pre>
</div>

<hr />

<p>
Header files such as <code>iostream.h</code> are for functions supplied by C++ standard library. When compiler links object files to create an executable program, it looks for the appropriate object code in a standard library file. The location of this standard library file generally is provided to the compiler when the compiler is installed.
</p>

<p>
Many C++ compilers bring every function mentioned in a header file into the program, even those functions that are not used. By creating multiple header files, a library's author makes it possible to use the library file selectively.
</p>
</div>
</div>

<div id="outline-container-orgd480184" class="outline-3">
<h3 id="orgd480184"><span class="section-number-3">9.2</span> 源码文件</h3>
<div class="outline-text-3" id="text-9-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 56: </span><code>class.cpp</code></label><pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">"class.h"</span>

<span class="org-constant">Class</span>::<span class="org-function-name">Class</span>() {...}
<span class="org-type">void</span> <span class="org-constant">Class</span>::<span class="org-function-name">foo</span>() {...}
</pre>
</div>

<p>
在源码文件中加载相应的头文件，是为了确保函数定义和函数原型保持一致，在不一致时编译器会报错。
</p>
</div>
</div>

<div id="outline-container-orgc30ae79" class="outline-3">
<h3 id="orgc30ae79"><span class="section-number-3">9.3</span> 客户文件</h3>
<div class="outline-text-3" id="text-9-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span>示例：=main.cpp=</label><pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">"class.h"</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">Class</span> <span class="org-variable-name">obj</span>;
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc939d0a" class="outline-3">
<h3 id="orgc939d0a"><span class="section-number-3">9.4</span> <code>#include</code></h3>
<div class="outline-text-3" id="text-9-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;file&gt;</span>
</pre>
</div>

<p>
<code>#include</code> 的效果相当于把被加载的文件内容加入到此处。
</p>

<ul class="org-ul">
<li>当加载的头文件为 <code>&lt;file&gt;</code> 时，编译器会先在 C++ 标准库目录下查找，之后在当前目录下查找。</li>
<li>当加载的头文件用 <code>"file.h"</code> 时，编译器会先在当前目录下查找，之后在 C++ 标准库目录下查找。</li>
</ul>
</div>
</div>

<div id="outline-container-org99fcff9" class="outline-3">
<h3 id="org99fcff9"><span class="section-number-3">9.5</span> <code>main()</code></h3>
<div class="outline-text-3" id="text-9-5">
<p>
每个程序必须定义一个 <code>main()</code> 函数。
</p>
</div>
</div>
</div>

<div id="outline-container-org363956c" class="outline-2">
<h2 id="org363956c"><span class="section-number-2">10</span> 编译</h2>
<div class="outline-text-2" id="text-10">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>.h</code></th>
<th scope="col" class="org-left">头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>.cpp</code></td>
<td class="org-left">源码文件</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>.o</code></td>
<td class="org-left">对象（object）文件</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgd06452c" class="outline-3">
<h3 id="orgd06452c"><span class="section-number-3">10.1</span> 编译过程</h3>
<div class="outline-text-3" id="text-10-1">
<p>
编译器使用 <code>.h</code> 文件，将 <code>.cpp</code> 文件编译为 <code>.o</code> 文件，之后将 <code>.o</code> 文件链接（link）成为可执行文件。
</p>

<p>
「编译」比「链接」耗时。
</p>

<p>
When compiler links object files to create an executable program, it encounters functions for which it has seen function prototypes but no corresponding function definitions. Whenever that happens, the C++ compiler looks for the appropriate object code.
</p>


<div class="figure">
<p><img src="../images/c++/01.png" alt="01.png" />
</p>
</div>

<p>
当一个头文件被修改时，必须重新编译所有加载这个头文件的源码文件。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 58: </span>当一个源码文件被修改时，只需要重新编译这个文件，并重新链接所有对象文件：</label><pre class="src src-sh">g++ -c foo.cpp
g++ -o exe foo.o bar.o baz.o
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb0357d" class="outline-3">
<h3 id="orgbb0357d"><span class="section-number-3">10.2</span> 编译器</h3>
<div class="outline-text-3" id="text-10-2">
<p>
常用 C++ 编译器：CC，g++，cxx。
</p>
</div>
</div>

<div id="outline-container-org415c566" class="outline-3">
<h3 id="org415c566"><span class="section-number-3">10.3</span> <code>g++</code></h3>
<div class="outline-text-3" id="text-10-3">
<div class="org-src-container">
<pre class="src src-sh">g++ &lt;options&gt; &lt;file&gt;
    -o &lt;file&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">Place the output into &lt;file&gt;</span>
    -c        <span class="org-comment-delimiter"># </span><span class="org-comment">Compile and assembly, but do not link</span>
    -v
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 59: </span>直接编译</label><pre class="src src-sh">$ g++ -Wall -W -Werror &lt;file&gt; -o &lt;file&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 60: </span>脚本编译</label><pre class="src src-sh"><span class="org-comment-delimiter">## </span><span class="org-comment">/bin/gccp</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">/bin/sh</span>
<span class="org-builtin">echo</span> compiling C++ using -ansi -pedantic-errors -Wall
g++ -ansi -pedantic-errors -Wall $<span class="org-variable-name">1</span> $<span class="org-variable-name">2</span> $<span class="org-variable-name">3</span>

<span class="org-comment-delimiter">## </span><span class="org-comment">&#32534;&#35793;</span>
$ gccp &lt;file&gt; -o &lt;file&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6864754" class="outline-3">
<h3 id="org6864754"><span class="section-number-3">10.4</span> <code>make</code></h3>
<div class="outline-text-3" id="text-10-4">
<p>
不使用 <code>make</code>
</p>
<ul class="org-ul">
<li>需要在 <code>g++</code> 命令中列出所有源码文件，命令复杂，不容易保存和重复使用</li>
<li>一个源码文件被修改后，需要重新编译所有文件，效率低</li>
</ul>

<p>
使用 <code>make</code>
</p>
<ul class="org-ul">
<li>将源文件的依赖关系和编译命令写在 <code>makefile</code> 文件中，通过 <code>make</code> 命令执行编译</li>
<li>当一个目标的依赖文件更新后， <code>make</code> 将会执行其后的所有命令行，以生成目标的新版本</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">make [&lt;options&gt;] [&lt;target&gt;]
    &lt;target&gt;  <span class="org-comment-delimiter"># </span><span class="org-comment">&#19981;&#25351;&#23450;&#26102;&#65292;&#23558;&#25191;&#34892; makefile &#20013;&#31532;&#19968;&#20010;&#30446;&#26631;&#30340;&#21629;&#20196;</span>
    -f &lt;file&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">&#25351;&#23450; makefile</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc46dd34" class="outline-3">
<h3 id="orgc46dd34"><span class="section-number-3">10.5</span> <code>makefile</code></h3>
<div class="outline-text-3" id="text-10-5">
<p>
<code>makefile</code> 由多个条目组成，每个条目包含：
</p>
<ul class="org-ul">
<li>目标：通常是一个文件</li>
<li>依赖：目标依赖的文件</li>
<li>命令：编译目标的命令</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 61: </span>语法</label><pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Comment                  # &#27880;&#37322;</span>
&lt;target&gt;: &lt;dependency&gt; ... <span class="org-comment-delimiter"># </span><span class="org-comment">&#20381;&#36182;&#25991;&#20214;&#26356;&#26032;&#21518;&#65288;&#36890;&#36807;&#27604;&#36739;&#26102;&#38388;&#25139;&#65289;&#65292;&#25165;&#37325;&#26032;&#32534;&#35793;&#36825;&#20010;&#30446;&#26631;</span>
    &lt;command&gt;              <span class="org-comment-delimiter"># </span><span class="org-comment">&#38656;&#35201;&#20197; tab &#24320;&#22836;</span>
</pre>
</div>

<hr />

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 62: </span><code>target</code> 为可执行文件（通常是 <code>makefile</code> 中第一个目标）</label><pre class="src src-sh">exe: alpha.o beta.o gamma.o
    g++ -Wall alpha.o beta.o gamma.o -o exe
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 63: </span><code>target</code> 为 <code>.o</code> 文件</label><pre class="src src-sh">alpha.o: alpha.cpp alpha.h beta.h <span class="org-comment-delimiter"># </span><span class="org-comment">alpha.cpp &#20381;&#36182;&#20110;&#65288;#include&#65289; beta.h</span>
    g++ -Wall -c alpha.cpp        <span class="org-comment-delimiter"># </span><span class="org-comment">&#20351;&#29992; -c &#36873;&#39033;&#21482;&#29983;&#25104; .o &#25991;&#20214;</span>

beta.h: gamma.h <span class="org-comment-delimiter"># </span><span class="org-comment">beta.h &#20381;&#36182;&#20110; gamma.h&#65292;&#22240;&#27492; alpha.o &#20063;&#20381;&#36182;&#20110; gamma.h</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">&#21333;&#29420;&#22768;&#26126;&#20256;&#36882;&#30340;&#65288;&#38750;&#30452;&#25509;&#30340;&#65289;&#20381;&#36182;&#65292;&#26356;&#31616;&#27905;&#65292;&#20063;&#36991;&#20813;&#36951;&#28431;</span>
</pre>
</div>

<hr />

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 64: </span>macros</label><pre class="src src-sh"><span class="org-variable-name">OBJS</span> = src1.o src2.o
<span class="org-variable-name">CC</span> = g++
<span class="org-variable-name">DEBUG</span> = -g                 <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for debugging</span>
<span class="org-variable-name">CFLAGS</span> = -Wall -c $(DEBUG) <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for compiling</span>
<span class="org-variable-name">LFLAGS</span> = -Wall $(DEBUG)    <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for linking</span>

p1: $(OBJS)
    $(CC) $(LFLAGS) $(OBJS) -o p1
</pre>
</div>

<hr />

<p>
Dummy targets
</p>
<ul class="org-ul">
<li>used to run commands without creating targets</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 65: </span><code>make clean</code></label><pre class="src src-sh">clean:
    \rm *.o *~ exe <span class="org-comment-delimiter"># </span><span class="org-comment">&#21024;&#38500;&#25152;&#26377; .o &#25991;&#20214;&#12289;emacs &#22791;&#20221;&#25991;&#20214;&#12289;&#25351;&#23450;&#21487;&#25191;&#34892;&#25991;&#20214;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 66: </span><code>make tar</code></label><pre class="src src-sh">tar:
    tar cvf project.tar alpha.h alpha.cpp beta.h ...
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 67: </span><code>make all</code></label><pre class="src src-sh">all: exe1 exe2 ... <span class="org-comment-delimiter"># </span><span class="org-comment">&#19968;&#27425;&#29983;&#25104;&#22810;&#20010;&#21487;&#25191;&#34892;&#25991;&#20214;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org309a62c" class="outline-2">
<h2 id="org309a62c"><span class="section-number-2">11</span> Links</h2>
<div class="outline-text-2" id="text-11">
<ol class="org-ol">
<li><a href="http://en.cppreference.com/w/">C++ Reference</a></li>
<li><a href="http://www.cplusplus.com/reference/">cplusplus.com</a></li>
<li><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li>
</ol>

<hr />

<ol class="org-ol">
<li><a href="https://www.learncpp.com/">Learn Cpp</a></li>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a></li>
<li><a href="https://isocpp.org/faq">C++ FAQ</a></li>
</ol>

<hr />

<ol class="org-ol">
<li><a href="http://www.gnu.org/software/make/manual/make.html">GNU make</a></li>
<li><a href="http://www.cs.umd.edu/class/fall2002/cmsc214/Tutorial/makefile.html">Makefiles</a></li>
<li><a href="http://people.engr.ncsu.edu/efg/210/s99/Notes/makefiles.html">Separate Compilation and Makefiles</a></li>
</ol>

<hr />

<ol class="org-ol">
<li><a href="http://cpp.sh/">C++ Shell</a></li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Victor Chen</p>
<p class="date">Created: 2019-12-29 Sun 22:01</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
