<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C++</title>
<!-- 2017-05-27 Sat 10:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/font.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/htmlize.css"/>
<script type="text/javascript" src="../../styles/readtheorg/js/jquery.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 类型</a>
<ul>
<li><a href="#sec-1-1">1.1. 类型</a></li>
<li><a href="#sec-1-2">1.2. 字符</a></li>
<li><a href="#sec-1-3">1.3. 数组</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. 语法</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. 字符串</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. 语法</a></li>
<li><a href="#sec-1-4-2">1.4.2. 运算</a></li>
<li><a href="#sec-1-4-3">1.4.3. 指针</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. 列表</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. 示例</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. 类型检验</a></li>
<li><a href="#sec-1-7">1.7. 类型转换</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. 隐式类型转换</a></li>
<li><a href="#sec-1-7-2">1.7.2. 显式类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. 变量</a>
<ul>
<li><a href="#sec-2-1">2.1. 声明 vs 定义</a></li>
<li><a href="#sec-2-2">2.2. 语法</a></li>
<li><a href="#sec-2-3">2.3. 作用域</a></li>
<li><a href="#sec-2-4">2.4. 类型</a></li>
<li><a href="#sec-2-5">2.5. 全局变量</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1. 示例</a></li>
<li><a href="#sec-2-5-2">2.5.2. <code>extern</code></a></li>
</ul>
</li>
<li><a href="#sec-2-6">2.6. 静态全局变量</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 常量</a>
<ul>
<li><a href="#sec-3-1">3.1. 语法</a></li>
<li><a href="#sec-3-2">3.2. 枚举常量</a></li>
<li><a href="#sec-3-3">3.3. 符号常量</a></li>
<li><a href="#sec-3-4">3.4. 宏</a></li>
</ul>
</li>
<li><a href="#sec-4">4. 运算符</a>
<ul>
<li><a href="#sec-4-1">4.1. 优先级</a></li>
<li><a href="#sec-4-2">4.2. 数学运算符</a></li>
<li><a href="#sec-4-3">4.3. 逻辑运算符</a></li>
<li><a href="#sec-4-4">4.4. 一元运算符</a></li>
<li><a href="#sec-4-5">4.5. 指针运算符</a></li>
<li><a href="#sec-4-6">4.6. <code>new</code></a></li>
<li><a href="#sec-4-7">4.7. <code>delete</code></a></li>
<li><a href="#sec-4-8">4.8. <code>sizeof</code></a></li>
<li><a href="#sec-4-9">4.9. <code>&gt;&gt;</code></a></li>
<li><a href="#sec-4-10">4.10. 运算符重载</a>
<ul>
<li><a href="#sec-4-10-1">4.10.1. 重载 <code>&lt;&lt;</code></a></li>
<li><a href="#sec-4-10-2">4.10.2. 重载 <code>&lt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. 指针</a>
<ul>
<li><a href="#sec-5-1">5.1. 内存</a></li>
<li><a href="#sec-5-2">5.2. 运算符</a></li>
<li><a href="#sec-5-3">5.3. 语法</a></li>
<li><a href="#sec-5-4">5.4. 指针数组</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 语句</a>
<ul>
<li><a href="#sec-6-1">6.1. <code>for</code></a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. 一般循环</a></li>
<li><a href="#sec-6-1-2">6.1.2. 迭代循环</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. <code>if</code></a></li>
<li><a href="#sec-6-3">6.3. <code>switch</code></a></li>
<li><a href="#sec-6-4">6.4. <code>try</code> <code>catch</code></a></li>
<li><a href="#sec-6-5">6.5. <code>while</code></a></li>
<li><a href="#sec-6-6">6.6. 注释</a></li>
</ul>
</li>
<li><a href="#sec-7">7. 函数</a>
<ul>
<li><a href="#sec-7-1">7.1. 定义</a></li>
<li><a href="#sec-7-2">7.2. 内存</a></li>
<li><a href="#sec-7-3">7.3. 参数</a>
<ul>
<li><a href="#sec-7-3-1">7.3.1. 类型</a></li>
<li><a href="#sec-7-3-2">7.3.2. 传值</a></li>
<li><a href="#sec-7-3-3">7.3.3. 传引用</a></li>
<li><a href="#sec-7-3-4">7.3.4. 默认值</a></li>
</ul>
</li>
<li><a href="#sec-7-4">7.4. 返回值</a></li>
<li><a href="#sec-7-5">7.5. 原型</a></li>
<li><a href="#sec-7-6">7.6. 模板</a></li>
</ul>
</li>
<li><a href="#sec-8">8. OO</a>
<ul>
<li><a href="#sec-8-1">8.1. 类</a>
<ul>
<li><a href="#sec-8-1-1">8.1.1. 定义</a></li>
<li><a href="#sec-8-1-2">8.1.2. 实例化</a></li>
<li><a href="#sec-8-1-3">8.1.3. 继承</a></li>
<li><a href="#sec-8-1-4">8.1.4. 示例</a></li>
</ul>
</li>
<li><a href="#sec-8-2">8.2. 抽象类</a></li>
<li><a href="#sec-8-3">8.3. 模板</a></li>
<li><a href="#sec-8-4">8.4. <code>friend</code></a></li>
<li><a href="#sec-8-5">8.5. 可见性</a></li>
<li><a href="#sec-8-6">8.6. 成员变量</a>
<ul>
<li><a href="#sec-8-6-1">8.6.1. 静态成员变量</a></li>
</ul>
</li>
<li><a href="#sec-8-7">8.7. 成员函数</a>
<ul>
<li><a href="#sec-8-7-1">8.7.1. 定义</a></li>
<li><a href="#sec-8-7-2">8.7.2. 执行</a></li>
<li><a href="#sec-8-7-3">8.7.3. 继承</a></li>
<li><a href="#sec-8-7-4">8.7.4. <code>this</code></a></li>
</ul>
</li>
<li><a href="#sec-8-8">8.8. 虚拟函数</a>
<ul>
<li><a href="#sec-8-8-1">8.8.1. 完全虚拟函数</a></li>
</ul>
</li>
<li><a href="#sec-8-9">8.9. 构造函数</a>
<ul>
<li><a href="#sec-8-9-1">8.9.1. 基类构造函数</a></li>
<li><a href="#sec-8-9-2">8.9.2. 复制构造函数</a></li>
</ul>
</li>
<li><a href="#sec-8-10">8.10. 析构函数</a>
<ul>
<li><a href="#sec-8-10-1">8.10.1. 虚拟析构函数</a></li>
</ul>
</li>
<li><a href="#sec-8-11">8.11. 函数原型</a></li>
</ul>
</li>
<li><a href="#sec-9">9. 程序</a>
<ul>
<li><a href="#sec-9-1">9.1. 头文件</a></li>
<li><a href="#sec-9-2">9.2. 源码文件</a></li>
<li><a href="#sec-9-3">9.3. 客户文件</a></li>
<li><a href="#sec-9-4">9.4. <code>#include</code></a></li>
<li><a href="#sec-9-5">9.5. <code>main()</code></a></li>
</ul>
</li>
<li><a href="#sec-10">10. 编译</a>
<ul>
<li><a href="#sec-10-1">10.1. 编译过程</a></li>
<li><a href="#sec-10-2">10.2. 编译器</a></li>
<li><a href="#sec-10-3">10.3. <code>g++</code></a></li>
<li><a href="#sec-10-4">10.4. <code>make</code></a></li>
<li><a href="#sec-10-5">10.5. <code>makefile</code></a></li>
</ul>
</li>
<li><a href="#sec-11">11. 链接</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类型</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 类型</h3>
<div class="outline-text-3" id="text-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="right">字节</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><b>整数</b></td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>short (int)</code></td>
<td class="right">2</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>int</code></td>
<td class="right">4</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>long (int)</code></td>
<td class="right">4</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>long long (int)</code></td>
<td class="right">8</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><b>浮点数</b></td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>float</code></td>
<td class="right">4</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>double</code></td>
<td class="right">8</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>long double</code></td>
<td class="right">8</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><b>字符</b></td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>char</code></td>
<td class="right">1</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>char16_t</code></td>
<td class="right">2</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>char32_t</code></td>
<td class="right">4</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>wchar_t</code></td>
<td class="right">&#xa0;</td>
<td class="left">表示支持的最大字符集的字符</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>string</code></td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
具体字节数因编译器而定。
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 字符</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<label class="org-src-name">字符由 <code>'</code> 包围时，表示它对应的整数值，即字符码（character code）。</label>
<pre class="src src-cpp"><span class="org-string">'A'</span> == 65;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 数组</h3>
<div class="outline-text-3" id="text-1-3">
<p>
一个数组中只能存储同一数据类型的元素，因为每个元素占用的内存空间相同，才可以使用数组索引值迅速定位元素位置。
</p>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 语法</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp">&lt;type&gt; &lt;name&gt;[&lt;size&gt;];
</pre>
</div>

<ul class="org-ul">
<li>定义之后，数组名成为一个常量指针，指向数组第一个元素。
</li>
<li>元素数不确定时，应尽量定义一个「足够大的」数组。
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">初始化</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">foo</span>[10] = {1, 2, 3}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#23450;&#21069;&#19977;&#20010;&#20803;&#32032;&#65292;&#20043;&#21518;&#40664;&#35748;&#20026; 0</span>
<span class="org-type">int</span> <span class="org-variable-name">foo</span>[10] = {0};       <span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#37096;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026; 0</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 字符串</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>实质是字符数组。
</li>
<li>由 <code>"</code> 包围。
</li>
<li>由 null 字符 <code>\0</code> 结尾，字符串操作函数通过 null 字符来确定字符串的结尾。
</li>
</ul>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> 语法</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<label class="org-src-name"><code>char*</code></label>
<pre class="src src-cpp"><span class="org-type">char</span>* &lt;name&gt;;
<span class="org-type">char</span>* &lt;name&gt; = <span class="org-string">"&lt;string&gt;"</span>;
&lt;name&gt; = <span class="org-keyword">new</span> <span class="org-type">char</span>[&lt;size&gt;];

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20989;&#25968;&#21442;&#25968;&#19982;&#36820;&#22238;&#20540;</span>
<span class="org-type">char</span>* <span class="org-function-name">foo</span>(<span class="org-type">char</span>* <span class="org-variable-name">str</span>) {
  <span class="org-keyword">return</span> <span class="org-string">"output"</span>;
}
cout &lt;&lt; foo(<span class="org-string">"input"</span>) &lt;&lt; endl;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>string</code></label>
<pre class="src src-cpp"><span class="org-type">string</span> &lt;name&gt;;
<span class="org-type">string</span> &lt;name&gt; = <span class="org-string">"&lt;string&gt;"</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> 运算</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">string</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>;
<span class="org-type">int</span> <span class="org-variable-name">l</span> = a.size(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38271;&#24230;</span>
a = b + c;        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36830;&#25509;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> 指针</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li>在表达式中，字符串的值是指向字符数组第一个元素的指针。
</li>
<li>当字符串用于调用函数时，传入的是指向字符数组第一个元素的指针。
</li>
<li>当函数返回字符串时，返回值是指向字符数组第一个元素的指针。
</li>
</ul>


<div class="figure">
<p><img src="../images/c++/04.png" alt="04.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 列表</h3>
<div class="outline-text-3" id="text-1-5">
<p>
When using a list, instead of an array, there is no need to anticipate how many objects will be stored, so it can conserve the space that would be wasted by safe worst-case estimates.
</p>

<p>
当多个对象通过指针链接在一起时，这些对象就属于一个 <b>列表</b> ，其中每一个对象称为列表的一个 <b>元素</b> 。
</p>

<dl class="org-dl">
<dt> 内部指针 </dt><dd>在类中设置一个指针成员变量，使其指向另一个此类对象，以此将多个对象串联在一起。<br  />
              通常不采用这种方式，因为需要对现有的、已经过测试的类进行修改，而且如果对象属于多个列表，则需要多个内部指针。
</dd>

<dt> 外部指针 </dt><dd>定义一个新类，包含两个指针成员变量，一个指向下一个此类对象，另一个指向列表元素对象。<br  />
              不需要修改现有类，可以创建多个列表，而且列表元素可以是子类的对象。
</dd>
</dl>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 示例</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
从头部插入元素的列表。
</p>

<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">element_param</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">element</span> {
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">list</span>&lt;<span class="org-type">element_param</span>&gt;;
  <span class="org-keyword">private</span>:
    <span class="org-type">element</span> *<span class="org-variable-name">next</span>;
    <span class="org-type">element_param</span> *<span class="org-variable-name">object</span>;
    <span class="org-function-name">element</span>(<span class="org-type">element_param</span> *<span class="org-variable-name">o</span>, <span class="org-type">element</span> *<span class="org-variable-name">e</span>) {
      object = o;
      next = e;
    }
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">list_param</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">list</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">list</span>() {
      first = <span class="org-constant">NULL</span>;
      current = first;
    }
    <span class="org-type">void</span> <span class="org-function-name">add</span>(<span class="org-type">list_param</span> *<span class="org-variable-name">object</span>) {
      first = <span class="org-keyword">new</span> <span class="org-type">element</span>&lt;list_param&gt;(object, first);
      current = first;
    }
    <span class="org-type">void</span> <span class="org-function-name">advance</span>() {
      current = current-&gt;next;
    }
    <span class="org-type">int</span> <span class="org-function-name">is_end</span>() {
      <span class="org-keyword">return</span> <span class="org-negation-char">!</span>current;
    }
    <span class="org-type">void</span> <span class="org-function-name">reset</span>() {
      current = first;
    }
    <span class="org-type">list_param</span>* <span class="org-function-name">access</span>() {
      <span class="org-keyword">return</span> current-&gt;object;
    }
  <span class="org-keyword">private</span>:
    <span class="org-type">element</span>&lt;<span class="org-type">list_param</span>&gt; *<span class="org-variable-name">first</span>;
    <span class="org-type">element</span>&lt;<span class="org-type">list_param</span>&gt; *<span class="org-variable-name">current</span>;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">使用</label>
<pre class="src src-cpp"><span class="org-type">list</span> <span class="org-variable-name">my_list</span>;
my_list.add(<span class="org-keyword">new</span> <span class="org-type">foo</span>());
...
my_list.reset();
<span class="org-keyword">for</span> (; <span class="org-negation-char">!</span>my_list.is_end(); my_list.advance()) {
  cout &lt;&lt; my_list.access()-&gt;attr &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 类型检验</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">Foo</span>* <span class="org-variable-name">test</span> = <span class="org-keyword">dynamic_cast</span> &lt;Foo*&gt; (obj);
<span class="org-keyword">if</span> (test != <span class="org-constant">NULL</span>)
    cout &lt;&lt; <span class="org-string">"object of class Foo"</span> &lt;&lt; end;
<span class="org-keyword">else</span>
    cout &lt;&lt; <span class="org-string">"not object of class Foo"</span> &lt;&lt; endl;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 类型转换</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> 隐式类型转换</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
当数学运算的操作数为不同类型时，较短的类型会被自动转换为较长的类型，以不丢失信息，如 <code>int</code> 与 <code>float</code> 进行运算时被转换为 <code>float</code> 。
</p>

<p>
当长类型的值被赋值给短类型的变量时，编译器会给出警告，如 <code>float</code> 值被赋给 <code>int</code> 变量。
</p>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> 显式类型转换</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-cpp">(&lt;type&gt;) &lt;expr&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp">a = (<span class="org-type">double</span>) b;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 变量</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 声明 vs 定义</h3>
<div class="outline-text-3" id="text-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><b>声明：</b></th>
<th scope="col" class="left">告知编译器一个标识符（变量、函数、参数）占用的内存空间（数据类型的长度），但不分配内存。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><b>定义：</b></td>
<td class="left">使编译器在编译时分配内存。</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>变量只可以被定义一次，但可以声明多次（比如通过 <code>extern</code> ）。
</li>
<li>当在所有函数体外引入一个变量时，它同时被声明和定义。
</li>
<li>当在函数体内引入一个变量时，它只被声明，而不被定义。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 语法</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<label class="org-src-name">声明</label>
<pre class="src src-cpp">&lt;type&gt; &lt;name&gt;;
&lt;type&gt; &lt;name&gt;, ...;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">初始化</label>
<pre class="src src-cpp">&lt;type&gt; &lt;name&gt; = &lt;expr&gt;;
&lt;type&gt; &lt;name&gt; = &lt;expr&gt;, ...;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 作用域</h3>
<div class="outline-text-3" id="text-2-3">
<dl class="org-dl">
<dt> Extent </dt><dd>The extent of a variable is the time during which a chunk of memory is allocated for that variable. <br  />
            The memory set aside for a global variable is never reallocated, so global variables are said to have <b>static extent</b>. <br  />
            The memory allocated for parameters and local variables is reallocated as soon as the corresponding function has finished executing, so parameters and local variables are said to have <b>dynamic extent</b>.
</dd>

<dt> Scope </dt><dd>The scope of a variable is that portion of a program where that variable can be evaluated or assigned. <br  />
           Global variables can be evaluated and assigned at any point in a program after they are defined, so global variables are said to have <b>universal scope</b>.
Parameters and local variables can be evaluated and assigned only in the function in which they are declared. Accordingly, parameters and local variables are said to have <b>local scope</b>.
</dd>
</dl>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 类型</h3>
<div class="outline-text-3" id="text-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><b>本地变量</b></th>
<th scope="col" class="left">在函数内定义的变量。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><b>全局变量</b></td>
<td class="left">在（所有）函数外定义的变量。</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><b>静态全局变量</b></td>
<td class="left">作用域只在一个文件内的全局变量。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 全局变量</h3>
<div class="outline-text-3" id="text-2-5">
<p>
在全局变量之后定义的函数，都可以使用该全局变量的值。
</p>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> 示例</h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#23616;&#21464;&#37327;</span>
<span class="org-type">int</span> <span class="org-variable-name">a</span> = 18;
<span class="org-type">int</span> <span class="org-variable-name">b</span> = 6;

<span class="org-type">int</span> <span class="org-function-name">function1</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#21517;&#30340;&#26412;&#22320;&#21464;&#37327;&#35206;&#30422;&#65288;override&#65289;&#20840;&#23616;&#21464;&#37327;</span>
  <span class="org-keyword">return</span> a - b;
}

<span class="org-type">int</span> <span class="org-function-name">function2</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">c</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;&#20840;&#23616;&#21464;&#37327;</span>
  c = a + b;
  <span class="org-keyword">return</span> c;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#21517;&#30340;&#26412;&#22320;&#21464;&#37327;&#35206;&#30422;&#65288;override&#65289;&#20840;&#23616;&#21464;&#37327;</span>
  <span class="org-type">int</span> <span class="org-variable-name">b</span> = 12;
  <span class="org-type">int</span> <span class="org-variable-name">c</span> = 0;
  a = function1(b, a); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#23616; a = &#26412;&#22320; b - &#20840;&#23616; a = 12 - 18 = -6</span>
  c = function2();     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26412;&#22320; c = &#20840;&#23616; a + &#20840;&#23616; b = -6 + 6 = 0</span>
  cout &lt;&lt; <span class="org-string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="org-string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="org-string">" c: "</span> &lt;&lt; c &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> <code>extern</code></h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
在多文件程序中，全局变量通常定义在一个文件中，在其他文件中使用全局变量时需要用 <code>extern</code> 进行声明。
</p>

<p>
使用 <code>extern</code> 声明全局变量时不能有初始值，因为初始值将迫使编译器为变量分配内存，使得变量在此处被定义（变量的定义只能有一次），而不是原本定义变量的位置。
</p>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">foo.h</span>
<span class="org-type">int</span> <span class="org-variable-name">var</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">bar.h</span>
<span class="org-keyword">extern</span> <span class="org-type">int</span> <span class="org-variable-name">var</span>;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 静态全局变量</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">static</span> &lt;<span class="org-type">type</span>&gt; &lt;name&gt;;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 常量</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 语法</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">const</span> &lt;<span class="org-type">type</span>&gt; &lt;name&gt; = &lt;expr&gt;;
</pre>
</div>

<p>
常量定义后不能修改，如果常量名出现在赋值表达式的左边，编译器将会报错。
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 枚举常量</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp"><span class="org-keyword">enum</span> {&lt;name&gt;, &lt;name&gt;, ...};         <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#20540;&#20174; 0 &#24320;&#22987;&#20381;&#27425;&#36882;&#22686; 1</span>
<span class="org-keyword">enum</span> {&lt;name&gt;, &lt;name&gt; = &lt;<span class="org-type">int</span>&gt;, ...}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#23450;&#20540;&#20043;&#21518;&#30340;&#24120;&#37327;&#20540;&#20174;&#27492;&#25351;&#23450;&#20540;&#24320;&#22987;&#32487;&#32493;&#36882;&#22686; 1</span>
<span class="org-keyword">enum</span> {&lt;name&gt; = <span class="org-string">'&lt;char&gt;'</span>, ...};      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#20351;&#29992;&#23383;&#31526;&#32534;&#30721;&#25351;&#23450;&#20540;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">枚举类型</label>
<pre class="src src-cpp"><span class="org-keyword">enum</span> &lt;<span class="org-type">type_name</span>&gt; {&lt;name&gt;, &lt;name&gt;, ...}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26522;&#20030;&#31867;&#22411;</span>
<span class="org-keyword">enum</span> &lt;<span class="org-type">type_name</span>&gt; &lt;var&gt;;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;&#26522;&#20030;&#31867;&#22411;&#22768;&#26126;&#21464;&#37327;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 符号常量</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-preprocessor">#define</span> &lt;name&gt; &lt;expr&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 宏</h3>
<div class="outline-text-3" id="text-3-4">
<p>
在编译为机器码之前，编译器将代码中的所有宏标识符替换为宏定义的字符序列。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 运算符</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 优先级</h3>
<div class="outline-text-3" id="text-4-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left"><b>结合律</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>::</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>sizeof()</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>!</code> <code>++</code> <code>--</code></td>
<td class="left">右向左</td>
</tr>

<tr>
<td class="left"><code>+</code> <code>-</code> （一元）</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>*</code> <code>&amp;</code> （指针）</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>new</code> <code>delete</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>(&lt;type&gt;)</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>*</code> <code>/</code> <code>%</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>+</code> <code>-</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>==</code> <code>!=</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&amp;</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>^</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&#124;</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&amp;&amp;</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&#124;&#124;</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>? :</code></td>
<td class="left">右向左</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>=</code></td>
<td class="left">右向左</td>
</tr>

<tr>
<td class="left"><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>&amp;=</code> <code>^=</code> <code>&#124;=</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>,</code></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 数学运算符</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">
<label class="org-src-name">整数进行除法时，结果会被截断（truncate），而不是四舍五入。</label>
<pre class="src src-cpp">5 / 3 <span class="org-comment-delimiter">// </span><span class="org-comment">== 1</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 逻辑运算符</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<label class="org-src-name"><code>&amp;&amp;</code> 可以替代 <code>if</code></label>
<pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;) &lt;statement&gt;;
(expr) &amp;&amp; &lt;statement&gt;;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>||</code> 可以替代 <code>if ... else</code></label>
<pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;); <span class="org-keyword">else</span> &lt;statement&gt;;
(&lt;expr&gt;) || &lt;statement&gt;;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 一元运算符</h3>
<div class="outline-text-3" id="text-4-4">
<p>
使用一元运算符可能会导致代码移植性问题，因为 C++ 不指定数学运算中操作数的求值（evaluate）顺序，以编译器而定，如 <code>++x + x</code> ， <code>++x</code> 可能在 <code>x</code> 之前或之后求值，使结果不确定。
</p>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 指针运算符</h3>
<div class="outline-text-3" id="text-4-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><b><code>*</code> 指针</b></th>
<th scope="col" class="left"><b><code>&amp;</code> 引用</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">有自己的内存空间</td>
<td class="left">没有自己的内存空间（相当于其他变量的别名）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">可以不初始化</td>
<td class="left">必须初始化为已定义的变量（已分配的内存）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">初始化后可以再指向其他地址</td>
<td class="left">初始化后不能再指向其他地址</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">值可以为 <code>NULL</code></td>
<td class="left">值不可以为 <code>NULL</code></td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<label class="org-src-name"><code>*</code> 示例</label>
<pre class="src src-cpp"><span class="org-type">int</span>* <span class="org-variable-name">a</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>;
<span class="org-type">int</span>* <span class="org-variable-name">b</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>;
<span class="org-type">int</span>* <span class="org-variable-name">c</span>;
*a = 1, *b = 1;
c = a, *c = 2; <span class="org-comment-delimiter">// </span><span class="org-comment">*a == 2</span>
c = b, *c = 3; <span class="org-comment-delimiter">// </span><span class="org-comment">*b == 3</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>&amp;</code> 示例</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">a</span>;
<span class="org-type">int</span>&amp; <span class="org-variable-name">b</span> = a;
a = 1;
b = 2; <span class="org-comment-delimiter">// </span><span class="org-comment">a == 2</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">可以将引用声明为常量，称为 free-standing 引用。</label>
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">int</span>&amp; <span class="org-variable-name">b</span> = 1;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> <code>new</code></h3>
<div class="outline-text-3" id="text-4-6">
<p>
从 free store 内存空间分配内存用于指定的对象，并返回地址。
</p>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-type">int</span>* <span class="org-variable-name">a</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>[10];
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> <code>delete</code></h3>
<div class="outline-text-3" id="text-4-7">
<p>
清理对象，回收内存空间，防止内存泄漏。
</p>

<div class="org-src-container">
<label class="org-src-name">语法</label>
<pre class="src src-cpp"><span class="org-keyword">delete</span> &lt;obj&gt;;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#25910;&#21333;&#20010;&#23545;&#35937;</span>
<span class="org-keyword">delete</span> [] &lt;array&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#25910;&#23545;&#35937;&#25968;&#32452;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-type">char</span> *<span class="org-variable-name">foo</span>;
foo = <span class="org-keyword">new</span> <span class="org-type">char</span>[10];
<span class="org-keyword">delete</span> [] foo;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> <code>sizeof</code></h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>获得类型（变量）的实际长度。
</li>
<li>可以加或不加 <code>()</code> 。
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">Empty</span> {};
<span class="org-keyword">struct</span> <span class="org-type">Base</span> { <span class="org-type">int</span> <span class="org-variable-name">a</span>; };

<span class="org-type">int</span> <span class="org-variable-name">a</span>[10];
<span class="org-type">Empty</span> <span class="org-variable-name">e</span>;
<span class="org-type">Base</span> <span class="org-variable-name">b</span>;

<span class="org-constant">std</span>::cout &lt;&lt; <span class="org-keyword">sizeof</span> a                 &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">40</span>
          &lt;&lt; (<span class="org-keyword">sizeof</span> a) / (<span class="org-keyword">sizeof</span> *a) &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">10</span>
          &lt;&lt; <span class="org-keyword">sizeof</span>(e)                &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">1</span>
          &lt;&lt; <span class="org-keyword">sizeof</span> b                 &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">4</span>
          &lt;&lt; <span class="org-keyword">sizeof</span> &amp;b                &lt;&lt; <span class="org-string">'\n'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">8</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> <code>&gt;&gt;</code></h3>
<div class="outline-text-3" id="text-4-9">
<p>
<code>&gt;&gt;</code> recognizes operands, such as input_buffer, that are pointers to character arrays. <code>&gt;&gt;</code> reads a string from the input stream up to the first whitespace character ― space, tab, or carriage return, then deposits that string into the array identified by the pointer.
</p>
</div>
</div>
<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10"><span class="section-number-3">4.10</span> 运算符重载</h3>
<div class="outline-text-3" id="text-4-10">
<div class="org-src-container">

<pre class="src src-cpp">&lt;type&gt; <span class="org-keyword">operator</span> &lt;<span class="org-type">symbol</span>&gt; (&lt;type&gt; &lt;param&gt;, ...) {
}
</pre>
</div>
</div>

<div id="outline-container-sec-4-10-1" class="outline-4">
<h4 id="sec-4-10-1"><span class="section-number-4">4.10.1</span> 重载 <code>&lt;&lt;</code></h4>
<div class="outline-text-4" id="text-4-10-1">
<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>:
    <span class="org-keyword">friend</span> <span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span> (<span class="org-type">ostream</span>&amp; <span class="org-variable-name">out</span>, <span class="org-type">Foo</span>&amp; <span class="org-variable-name">f</span>) {
      out &lt;&lt; f.bar;
      <span class="org-keyword">return</span> out;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-10-2" class="outline-4">
<h4 id="sec-4-10-2"><span class="section-number-4">4.10.2</span> 重载 <code>&lt;</code></h4>
<div class="outline-text-4" id="text-4-10-2">
<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;</span> (<span class="org-keyword">const</span> <span class="org-type">Foo</span> <span class="org-variable-name">f</span>) {
      <span class="org-keyword">return</span> bar &lt; f.bar;
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 指针</h2>
<div class="outline-text-2" id="text-5">
<p>
指针的大小取决于编译器。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 内存</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Ordinarily, when a global variable is defined, C++ compiler allocates the memory required to hold an object corresponding to the variable's type.
</p>

<p>
When using pointer, C++ allocates only a small amount of memory for a pointer at compile time, deferring until run time the allocation of memory for an object. Run-time allocation reduces the memory consumed by program. 
</p>


<div class="figure">
<p><img src="../images/c++/03.png" alt="03.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 运算符</h3>
<div class="outline-text-3" id="text-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>*</code></th>
<th scope="col" class="left">Dereferencing operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>&amp;</code></td>
<td class="left">Address-of operator，C++ 中较少使用</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>-&gt;</code></td>
<td class="left">Class-pointer operator，等价于 <code>(*&lt;pointer&gt;).</code></td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left"><b>值</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>&lt;pointer&gt;</code></td>
<td class="left">地址</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>*&lt;pointer&gt;</code></td>
<td class="left">对象</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>&amp;&lt;var&gt;</code></td>
<td class="left">地址</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 语法</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp">&lt;type&gt; *&lt;pointer&gt;;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">赋值</label>
<pre class="src src-cpp">&lt;pointer&gt; = <span class="org-keyword">new</span> &lt;<span class="org-type">type</span>&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">new &#34920;&#36798;&#24335;&#36820;&#22238;&#30340;&#26159;&#20998;&#37197;&#30340;&#22320;&#22336;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#65306;</span>
&lt;var&gt; = <span class="org-keyword">new</span> &lt;<span class="org-type">type</span>&gt;;
&lt;pointer&gt; = &amp;&lt;var&gt;;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">类对象</label>
<pre class="src src-cpp">&lt;Class&gt; *&lt;pointer&gt;;
&lt;pointer&gt; = <span class="org-keyword">new</span> &lt;<span class="org-type">Class</span>&gt;;

&lt;pointer&gt;-&gt;&lt;var&gt; = ... ;
&lt;pointer&gt;-&gt;&lt;function&gt;();
<span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#65306;</span>
(*&lt;pointer&gt;).&lt;var&gt; = ... ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#25104;&#21592;&#36816;&#31639;&#31526; . &#30340;&#20248;&#20808;&#32423;&#39640;&#20110;&#25351;&#38024;&#36816;&#31639;&#31526; *</span>
(*&lt;pointer&gt;).&lt;function&gt;();
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 指针数组</h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp">&lt;type&gt; *&lt;pointer&gt;[&lt;n&gt;]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#36816;&#31639;&#31526; * &#20248;&#20808;&#32423;&#39640;&#20110; []&#65292;&#22240;&#27492;&#23450;&#20041;&#30340;&#26159; n &#20010;&#25351;&#38024;&#30340;&#25968;&#32452;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">类对象</label>
<pre class="src src-cpp">&lt;Class&gt; *&lt;pointer&gt;[&lt;n&gt;];
&lt;pointer&gt;[&lt;idx&gt;] = <span class="org-keyword">new</span> &lt;<span class="org-type">Class</span>&gt;;

(*&lt;pointer&gt;[&lt;idx&gt;]).&lt;var&gt; = ... ; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#25104;&#21592;&#36816;&#31639;&#31526; . &#30340;&#20248;&#20808;&#32423;&#39640;&#20110;&#25351;&#38024;&#36816;&#31639;&#31526; *</span>
(*&lt;pointer&gt;[&lt;idx&gt;]).&lt;function&gt;();
<span class="org-comment-delimiter">// </span><span class="org-comment">&#25110;</span>
&lt;pointer&gt;[&lt;idx&gt;]-&gt;&lt;var&gt; = ... ;
&lt;pointer&gt;[&lt;idx&gt;]-&gt;&lt;function&gt;();
</pre>
</div>

<p>
定义类对象指针数组中的指针，可以指向某类或其子类的对象。因此通过类对象指针数组，可以解决「普通数组要求其中的元素数据类型完全一致」的问题。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 语句</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> <code>for</code></h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> 一般循环</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">for</span> (&lt;init&gt;; &lt;expr&gt;; &lt;incr&gt;) {
}
</pre>
</div>

<p>
当 <code>&lt;expr&gt;</code> 的值为 <code>0</code> 或 <code>NULL</code> 时，循环中止。
</p>

<div class="org-src-container">
<label class="org-src-name">循环体的内容可以合并到条件中</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">counter</span>, <span class="org-variable-name">result</span> = 1;
<span class="org-keyword">for</span> (counter = n; counter; --counter) {
  result *= 2;
}

<span class="org-type">int</span> <span class="org-variable-name">counter</span>, <span class="org-variable-name">result</span>;
<span class="org-keyword">for</span> (counter = n, result = 1;
     counter;
     --counter, result *= 2);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2"><span class="section-number-4">6.1.2</span> 迭代循环</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
从 C++ 11 开始 <code>for</code> 支持迭代（range-based）循环。
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">for</span> (&lt;type&gt; &lt;elem&gt; : &lt;range&gt;) {
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">nums</span>[] = {1, 2, 3};
<span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">num</span> : nums) {
  cout &lt;&lt; num &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> <code>if</code></h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">if</span> (&lt;expr&gt;) {
  ...
} <span class="org-keyword">else</span> <span class="org-keyword">if</span> (&lt;expr&gt;) {
  ...
} <span class="org-keyword">else</span> {
  ...
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> <code>switch</code></h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">switch</span> (&lt;expr&gt;) {
  <span class="org-keyword">case</span> &lt;<span class="org-type">int</span>&gt;:
    ...;
    <span class="org-keyword">break</span>;
  <span class="org-keyword">default</span>:
    ...;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> <code>try</code> <code>catch</code></h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">try</span> {
    ...
} <span class="org-keyword">catch</span> (exception&amp; e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> <code>while</code></h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">while</span> (&lt;expr&gt;) {
  ...
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">do</span> {
  ...
} <span class="org-keyword">while</span> (&lt;expr&gt;);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> 注释</h3>
<div class="outline-text-3" id="text-6-6">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Short comment</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment">Long comment ...</span>
<span class="org-comment">that just goes on ...</span>
<span class="org-comment">and on ...</span>
<span class="org-comment">*/</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 函数</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 定义</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp">&lt;type&gt; &lt;name&gt; (&lt;type&gt; &lt;param&gt;, ...) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Declarations</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Statements</span>
}
</pre>
</div>

<p>
函数只可以被定义一次，但可以声明多次（通过函数原型）。
</p>

<p>
编译器通常要求函数定义必须出现在函数调用之前。
</p>

<p>
C++ 允许同名函数，但同名函数的参数类型必须不同。被重复使用的函数名称为被重载（overload）。调用被重载的函数时，编译器通过传入参数的类型进行匹配，确定实际调用的函数。
</p>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 内存</h3>
<div class="outline-text-3" id="text-7-2">
<p>
C++ is a call-by-value language. When a function is called, copies of the value of the arguments become the value of the parameters. C++ reserves a chunk of memory for each parameter every time the function is called. Therefore a local variable in a function doesn't affect the values of variable with the same name outside the function.
</p>


<div class="figure">
<p><img src="../images/c++/05.png" alt="05.png" />
</p>
</div>

<hr  />

<p>
The memory set aside for each function's call-by-value parameters and local variables is set aside only temporarily. When a function is called, memory chunks are pushed onto the end of an area of memory called the stack; after a function returns, the memory in those chunks is overwritten as soon as subsequent function calls cause new memory chunks to be pushed onto the stack.
</p>

<p>
When a function is to return the value of a call-by-value parameter or of a local variable, the C++ compiler arranges, by default, for such values to be copied before they are lost.
</p>


<div class="figure">
<p><img src="../images/c++/06.png" alt="06.png" />
</p>
</div>

<p>
Some functions involve a pass-through object: an object that is handed to the function via a call-by-reference parameter, without copying, and is to be returned as the function's value, also without copying.
</p>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 参数</h3>
<div class="outline-text-3" id="text-7-3">
</div><div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1"><span class="section-number-4">7.3.1</span> 类型</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
参数的类型默认为 <code>int</code> 。
</p>
</div>
</div>
<div id="outline-container-sec-7-3-2" class="outline-4">
<h4 id="sec-7-3-2"><span class="section-number-4">7.3.2</span> 传值</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
<a id="excess_reclamation_bug" name="excess_reclamation_bug"></a>
参数为对象时，传值会出现的问题（excess-reclamation bug）：C++ 通过一个<a href="#copy_constructor">复制构造函数（copy constructor）</a>复制对象，C++ 编译器会实现一个默认的复制构造函数，逻辑是复制对象所有的成员变量。如果一个成员变量是指针类型，则指针被复制，但指针所指的变量不被复制，即两个指针（原对象的指针和复制对象的指针）指向同一块内存。当复制对象的内存被回收时（即传值函数返回时），对象的析构函数可能同时会回收（通过 <code>delete</code> ）指针所指变量的内存，这导致原对象的指针指向空（在一段时间内该指针还可以返回数据，直到这部分内存被重新分配并覆盖）。
</p>


<div class="figure">
<p><img src="../images/c++/07.png" alt="07.png" />
</p>
</div>

<p>
可能的解决方法：
</p>
<ul class="org-ul">
<li>自定义复制构造函数，在复制对象时，连指针变量指向的变量也进行复制
</li>
<li>在对象作为函数参数时，使用传引用的方式
</li>
</ul>

<p>
通常采用的是「传引用」的解决方法，因为编程的一个理念（philosophy）是：对象一般代表的是真实世界中的独立个体，对象的创建、复制、销毁应该模仿真实世界中的模式，即不应该在对象作为参数进行函数调用前后，复制和销毁对象。
</p>

<p>
为避免对象被作为传值参数（被复制），可以将类的复制构造函数声明为 <code>private</code> ，当类对象以传值方式作为函数参数时，编译会报错。、
</p>

<div class="org-src-container">
<label class="org-src-name">可以只在基类中声明为原型：</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>: <span class="org-function-name">Foo</span>(<span class="org-type">Foo</span>&amp;);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-3-3" class="outline-4">
<h4 id="sec-7-3-3"><span class="section-number-4">7.3.3</span> 传引用</h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
参数默认为传值（call-by-value），需要传引用（call-by-reference）时，使用 <code>&amp;</code> 声明。需要传引用的场合：
</p>

<ul class="org-ul">
<li>大的对象进行复制速度较慢。
</li>
<li>函数需要对传入参数本身进行修改。
</li>
<li>参数类型是基类，而传入值是多态的子类对象，长度可能不同。
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span>&amp; <span class="org-variable-name">bar</span>) {}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">示例：传数组引用</label>
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">bar</span>[]) {}
<span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">bar</span>[10]) {}
<span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span>* <span class="org-variable-name">bar</span>) {}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-3-4" class="outline-4">
<h4 id="sec-7-3-4"><span class="section-number-4">7.3.4</span> 默认值</h4>
<div class="outline-text-4" id="text-7-3-4">
<div class="org-src-container">
<label class="org-src-name">带有默认值的参数必须在最右：</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span> = 1) {}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 返回值</h3>
<div class="outline-text-3" id="text-7-4">
<p>
只有返回值类型为 <code>void</code> 的函数可以没有 <code>return</code> 语句。一些程序员认为正确的做法是使用空的 <code>return</code> 语句。
</p>

<hr  />

<p>
函数返回值类型后加 <code>&amp;</code> ，表示函数返回值时不进行复制，而是直接返回。
</p>

<div class="org-src-container">

<pre class="src src-cpp">&lt;type&gt;&amp; &lt;function&gt;(...) {
}
</pre>
</div>

<p>
只有在参数是传递引用时，返回值才可以是引用，即传入和返回的是同一个变量的引用，比如运算符重载。
</p>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> 原型</h3>
<div class="outline-text-3" id="text-7-5">
<p>
一个函数声明，没有参数名和函数体，只有参数类型和返回类型。通过原型，编译器可以为此函数的调用做准备（如何分配内存），使得其他函数可以在未定义函数体的情况下对其进行调用。
</p>

<ul class="org-ul">
<li>普通函数原型是为了解决「相互调用的函数定义顺序」的问题。
</li>
<li>类函数原型是为了将类函数的定义移动到类定义之外。
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">示例：斐波那契数列（兔子繁殖问题）</label>
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Function prototype</span>
<span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Function definitions requiring function prototype:</span>
<span class="org-type">int</span> <span class="org-function-name">previous_month</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) { <span class="org-keyword">return</span> rabbits (n - 1); }
<span class="org-type">int</span> <span class="org-function-name">penultimate_month</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) { <span class="org-keyword">return</span> rabbits (n - 2); }

<span class="org-comment-delimiter">// </span><span class="org-comment">Function definition</span>
<span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">if</span> (n == 0 || n == 1)
    <span class="org-keyword">return</span> 1;
  <span class="org-keyword">else</span> <span class="org-keyword">return</span> previous_month (n) + penultimate_month (n);
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">原型可以加参数名</label>
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">rabbits</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> 模板</h3>
<div class="outline-text-3" id="text-7-6">
<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">t</span>&gt; <span class="org-type">void</span> <span class="org-function-name">print_vector</span>(<span class="org-type">vector</span>&lt;<span class="org-type">t</span>&gt; <span class="org-variable-name">v</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">t</span> <span class="org-variable-name">elem</span>: v)
    cout &lt;&lt; elem &lt;&lt; endl;
  <span class="org-keyword">return</span>;
}

<span class="org-type">print_vector</span>&lt;<span class="org-type">int</span>&gt;(<span class="org-variable-name">int_vector</span>);
<span class="org-type">print_vector</span>&lt;stirng&gt;(<span class="org-variable-name">string_vector</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> OO</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 类</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> 定义</h4>
<div class="outline-text-4" id="text-8-1-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31867;&#23450;&#20041;&#32467;&#26463;&#26377; ;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-1-2" class="outline-4">
<h4 id="sec-8-1-2"><span class="section-number-4">8.1.2</span> 实例化</h4>
<div class="outline-text-4" id="text-8-1-2">
<div class="org-src-container">
<label class="org-src-name">作为数据类型声明变量</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;</span>
<span class="org-type">Foo</span> <span class="org-variable-name">foo</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#20363;&#21270;</span>
<span class="org-type">Foo</span> <span class="org-function-name">foo</span>(1);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">类定义的同时声明变量</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {} <span class="org-type">foo1</span> <span class="org-variable-name">foo2</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-1-3" class="outline-4">
<h4 id="sec-8-1-3"><span class="section-number-4">8.1.3</span> 继承</h4>
<div class="outline-text-4" id="text-8-1-3">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> : <span class="org-keyword">public</span> <span class="org-type">Bar</span>, <span class="org-keyword">protected</span> <span class="org-type">Qux</span> {};
</pre>
</div>

<ul class="org-ul">
<li>支持多继承。
</li>
<li>基类必须在子类之前定义。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-1-4" class="outline-4">
<h4 id="sec-8-1-4"><span class="section-number-4">8.1.4</span> 示例</h4>
<div class="outline-text-4" id="text-8-1-4">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Class</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>;
<span class="org-keyword">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">va</span>, <span class="org-type">int</span> <span class="org-variable-name">vb</span>) {
        a = va;
        b = vb;
        <span class="org-keyword">return</span>;
    }
    <span class="org-type">void</span> <span class="org-function-name">bar</span>();
}

<span class="org-type">void</span> <span class="org-constant">Class</span>::<span class="org-function-name">bar</span>() {
    <span class="org-keyword">return</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Class</span> <span class="org-variable-name">obj</span>;
    obj.foo(1, 2);
    obj.bar();
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 抽象类</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>抽象类不可被实例化。
</li>
<li>通过定义完全虚拟函数来实现抽象类，最简单的方式是将析构函数定义为完全虚拟。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
<span class="org-keyword">public</span>:
    <span class="org-function-name">Foo</span>() {}
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Foo</span>() = 0;
};
<span class="org-constant">Foo</span>::~<span class="org-function-name">Foo</span>() {}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 模板</h3>
<div class="outline-text-3" id="text-8-3">
<p>
模板是一种代码重用方式，使同一个类可以用于不同的数据类型。
</p>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Type</span>&gt; <span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-type">Type</span> <span class="org-variable-name">t</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Foo</span>(<span class="org-type">Type</span> <span class="org-variable-name">v</span>) : t(v) {}
  <span class="org-type">Type</span> <span class="org-function-name">add</span>(<span class="org-type">Type</span> <span class="org-variable-name">v</span>) { <span class="org-keyword">return</span> t + v; }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization</span>
<span class="org-keyword">template</span> &lt;&gt; <span class="org-keyword">class</span> <span class="org-type">Foo</span> &lt;<span class="org-type">string</span>&gt; {
  <span class="org-type">string</span> <span class="org-variable-name">s</span>;
<span class="org-keyword">public</span>:
  <span class="org-function-name">Foo</span>(<span class="org-type">string</span> <span class="org-variable-name">v</span>) : s(v) {}
  <span class="org-type">string</span> <span class="org-function-name">add</span>(<span class="org-type">string</span> <span class="org-variable-name">v</span>) { <span class="org-keyword">return</span> s + v; }
};

<span class="org-type">Foo</span>&lt;<span class="org-type">double</span>&gt; <span class="org-function-name">foo1</span>(double1);
cout &lt;&lt; foo1.add(double2) &lt;&lt; endl;
<span class="org-type">Foo</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">foo2</span>(int1);
cout &lt;&lt; foo2.add(int2) &lt;&lt; endl;
<span class="org-type">Foo</span>&lt;<span class="org-type">string</span>&gt; <span class="org-function-name">foo3</span>(string1);
cout &lt;&lt; foo3.add(string2) &lt;&lt; endl;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> <code>friend</code></h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">ClassA</span>&gt; {
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> &lt;<span class="org-type">ClassB</span>&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22768;&#26126; ClassB &#20026; ClassA &#30340; friend</span>
  <span class="org-keyword">private</span>:
    &lt;type&gt; &lt;var&gt;; <span class="org-comment-delimiter">// </span><span class="org-comment">ClassA &#30340;&#25152;&#26377;&#25104;&#21592;&#21464;&#37327;&#21644;&#20989;&#25968;&#23545;&#20110; ClassB &#37117;&#26159; public &#30340;</span>
    &lt;ClassA&gt;() {
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 可见性</h3>
<div class="outline-text-3" id="text-8-5">
<p>
成员变量、函数默认为 <code>private</code> 。
</p>

<hr  />

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" class="no-border">
<caption class="t-above"><span class="table-number">Table 1:</span> 继承时通过声明基类的可见性，批量改变基类中成员的可见性：</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>protected</code></th>
<th scope="col" class="left">基类中的 <code>public</code> 成员在子类中为 <code>protected</code> 。</th>
</tr>

<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left"><code>protected</code> 和 <code>private</code> 成员不变。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>private</code></td>
<td class="left">基类中的 <code>public</code> 和 <code>protected</code> 成员在子类中为 <code>private</code> 。</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>private</code> 成员不变。</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">First</span> {
  <span class="org-keyword">public</span>: <span class="org-type">double</span> <span class="org-variable-name">var1</span>, <span class="org-variable-name">var2</span>;
}

<span class="org-keyword">class</span> <span class="org-type">Second</span> : <span class="org-keyword">protected</span> <span class="org-type">First</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312; Second &#20013; var1 &#21644; var2 &#20026; protected</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#35265;&#24615;&#32487;&#32493;&#20256;&#36882;</span>
<span class="org-keyword">class</span> <span class="org-type">Third</span> : <span class="org-keyword">public</span> <span class="org-type">Second</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312; Third &#20013; var1 &#21644; var2 &#20381;&#28982;&#20026; protected</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> 成员变量</h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    &lt;visib&gt;: &lt;type&gt; &lt;var&gt;;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">访问对象的成员变量</label>
<pre class="src src-cpp">&lt;Class&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;var&gt; = &lt;value&gt;;
</pre>
</div>
</div>

<div id="outline-container-sec-8-6-1" class="outline-4">
<h4 id="sec-8-6-1"><span class="section-number-4">8.6.1</span> 静态成员变量</h4>
<div class="outline-text-4" id="text-8-6-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">bar</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;</span>
}
<span class="org-type">int</span> <span class="org-constant">Foo</span>::<span class="org-variable-name">bar</span> = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#65292;&#38656;&#35201;&#22768;&#26126;&#31867;&#22411;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> 成员函数</h3>
<div class="outline-text-3" id="text-8-7">
</div><div id="outline-container-sec-8-7-1" class="outline-4">
<h4 id="sec-8-7-1"><span class="section-number-4">8.7.1</span> 定义</h4>
<div class="outline-text-4" id="text-8-7-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;type&gt; &lt;var&gt;, &lt;var&gt;;
            &lt;type&gt; &lt;function&gt;() {
                <span class="org-keyword">return</span> &lt;var&gt;;
            }
};
</pre>
</div>

<p>
Each member function has one special argument:
</p>
<ul class="org-ul">
<li>the value is a class object that belongs to the same class as does the member function
</li>
<li>it does not appear in parentheses, instead, it is joined, via the class-member operator <code>.</code> to the name of the member function
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-7-2" class="outline-4">
<h4 id="sec-8-7-2"><span class="section-number-4">8.7.2</span> 执行</h4>
<div class="outline-text-4" id="text-8-7-2">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
&lt;Class&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;function&gt;();
&lt;obj&gt;.&lt;Parent&gt;::&lt;function&gt;(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-7-3" class="outline-4">
<h4 id="sec-8-7-3"><span class="section-number-4">8.7.3</span> 继承</h4>
<div class="outline-text-4" id="text-8-7-3">
<p>
继承关系中，子类与基类有同名函数时，除非指定，否则默认调用子类中定义的函数。
</p>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Parent</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
<span class="org-keyword">class</span> &lt;<span class="org-type">Child</span>&gt; : <span class="org-keyword">public</span> &lt;<span class="org-type">Parent</span>&gt; {
    <span class="org-keyword">public</span>: &lt;function&gt;() { ... }
};
&lt;Child&gt; &lt;obj&gt;;
&lt;obj&gt;.&lt;function&gt;();           <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#23376;&#31867;&#30340;&#20989;&#25968;</span>
&lt;obj&gt;.&lt;Parent&gt;::&lt;function&gt;(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#30340;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-7-4" class="outline-4">
<h4 id="sec-8-7-4"><span class="section-number-4">8.7.4</span> <code>this</code></h4>
<div class="outline-text-4" id="text-8-7-4">
<p>
<code>this</code> 用于在一个成员函数中（使用当前的对象）调用另一个成员函数。
</p>

<div class="org-src-container">
<label class="org-src-name">语法</label>
<pre class="src src-cpp"><span class="org-function-name">foo</span>() {
  cout &lt;&lt; (*<span class="org-keyword">this</span>).bar();
  cout &lt;&lt; <span class="org-keyword">this</span>-&gt;bar();
  cout &lt;&lt; bar();        <span class="org-comment-delimiter">// </span><span class="org-comment">&#38544;&#24335;&#20889;&#27861;&#65292;this &#21487;&#20197;&#30465;&#30053;</span>
}
<span class="org-function-name">bar</span>() {
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> 虚拟函数</h3>
<div class="outline-text-3" id="text-8-8">
<div class="org-src-container">
<label class="org-src-name">C++ 在编译时就决定将调用的成员函数，称为静态绑定（static binding），使得子类无法实现多态。</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a student."</span>; }
};

<span class="org-type">Student</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a person.</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">虚拟成员函数（virtual member function）使得程序在运行时，而不是编译时，选择将调用的函数。</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;&#20013;&#19981;&#38656;&#35201;&#37325;&#26032;&#22768;&#26126;&#20026; virtual &#65292;&#20294;&#36890;&#24120;&#20173;&#26174;&#24335;&#22768;&#26126;</span>
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">about</span>() { cout &lt;&lt; <span class="org-string">"I'm a student."</span>; }
};

<span class="org-type">Student</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
p-&gt;about(); <span class="org-comment-delimiter">// </span><span class="org-comment">I'm a student.</span>
</pre>
</div>
</div>

<div id="outline-container-sec-8-8-1" class="outline-4">
<h4 id="sec-8-8-1"><span class="section-number-4">8.8.1</span> 完全虚拟函数</h4>
<div class="outline-text-4" id="text-8-8-1">
<p>
当某个子类未定义虚拟成员函数，以覆盖基类的定义时，基类的虚拟成员函数将被调用。完全虚拟函数（pure virtual function）可以避免基类的虚拟成员函数被调用。
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">bar</span>() = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#20840;&#34394;&#25311;</span>
}
</pre>
</div>

<ul class="org-ul">
<li>子类未实现完全虚拟函数时，编译会报错。
</li>
<li>定义了完全虚拟函数的类为抽象类，无法实例化。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9"><span class="section-number-3">8.9</span> 构造函数</h3>
<div class="outline-text-3" id="text-8-9">
<ul class="org-ul">
<li>与类同名。
</li>
<li>没有返回值类型。
</li>
<li>默认构造函数没有参数。
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Foo</span>() {}              <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;</span>
    <span class="org-function-name">Foo</span>(): bar(1) {}      <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#21021;&#22987;&#21270;&#31616;&#20889;</span>
    <span class="org-function-name">Foo</span>(<span class="org-type">int</span> <span class="org-variable-name">v</span>) {}         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;</span>
    <span class="org-function-name">Foo</span>(<span class="org-type">int</span> <span class="org-variable-name">v</span>): bar(v) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;&#21021;&#22987;&#21270;&#31616;&#20889;</span>
};

<span class="org-type">Foo</span> <span class="org-variable-name">foo</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
<span class="org-type">Foo</span> <span class="org-function-name">foo</span>(v); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#33258;&#23450;&#20041;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">调用基类构造函数</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
<span class="org-keyword">protected</span>:
    <span class="org-type">int</span> <span class="org-variable-name">id</span>;
    <span class="org-type">string</span> <span class="org-variable-name">firstname</span>;
    <span class="org-type">string</span> <span class="org-variable-name">lastname</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Person</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>, <span class="org-type">string</span> <span class="org-variable-name">fn</span>, <span class="org-type">string</span> <span class="org-variable-name">ln</span>) : id(id), <span class="org-type">firstname</span>(<span class="org-variable-name">fn</span>), lastname(ln) {}
};

<span class="org-keyword">class</span> <span class="org-type">Student</span>: <span class="org-keyword">public</span> <span class="org-type">Person</span> {
<span class="org-keyword">protected</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">scores</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">Student</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>, <span class="org-type">string</span> <span class="org-variable-name">fn</span>, <span class="org-type">string</span> <span class="org-variable-name">ln</span>, <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">scores</span>): Person(id, fn, ln), scores(scores) {}
};
</pre>
</div>
</div>

<div id="outline-container-sec-8-9-1" class="outline-4">
<h4 id="sec-8-9-1"><span class="section-number-4">8.9.1</span> 基类构造函数</h4>
<div class="outline-text-4" id="text-8-9-1">
<p>
实例化子类时，基类的构造函数先于子类的被执行。
</p>

<div class="org-src-container">

<pre class="src src-cpp">&lt;ChildClass&gt;() : &lt;ParentClass&gt;(&lt;value&gt;, ...)
                 [, &lt;ParentClass&gt;(&lt;value&gt;, ...)]
                 {}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22522;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box</span> : <span class="org-keyword">public</span> <span class="org-type">container</span> {
  <span class="org-keyword">public</span>: 
    <span class="org-type">double</span> <span class="org-variable-name">height</span>, <span class="org-variable-name">width</span>, <span class="org-variable-name">length</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box</span>() {}
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33258;&#23450;&#20041;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box</span>(<span class="org-type">double</span> <span class="org-variable-name">h</span>, <span class="org-type">double</span> <span class="org-variable-name">w</span>, <span class="org-type">double</span> <span class="org-variable-name">l</span>) {
      height = h; width = w; length = l;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box_car</span> : <span class="org-keyword">public</span> <span class="org-type">railroad_car</span>, <span class="org-keyword">public</span> <span class="org-type">box</span> {
  <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;&#22522;&#31867;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
    <span class="org-function-name">box_car</span>() : box(10.5, 9.5, 40.0) {}
};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&#22522;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">railroad_car</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">char</span> *<span class="org-variable-name">serial_number</span>;
    <span class="org-function-name">railroad_car</span>() {}
    <span class="org-function-name">railroad_car</span>(<span class="org-type">char</span> *<span class="org-variable-name">input_buffer</span>) {
      serial_number = <span class="org-keyword">new</span> <span class="org-type">char</span>[strlen(input_buffer) + 1];
      strcpy(serial_number, input_buffer);
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#31867;</span>
<span class="org-keyword">class</span> <span class="org-type">box_car</span> : <span class="org-keyword">public</span> <span class="org-type">railroad_car</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">box_car</span>() {}
    <span class="org-function-name">box_car</span>(<span class="org-type">char</span> *<span class="org-variable-name">input_buffer</span>) : railroad_car(input_buffer) {}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-9-2" class="outline-4">
<h4 id="sec-8-9-2"><span class="section-number-4">8.9.2</span> 复制构造函数</h4>
<div class="outline-text-4" id="text-8-9-2">
<p>
<a id="copy_constructor" name="copy_constructor"></a>
</p>

<div class="org-src-container">
<label class="org-src-name">示例</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Foo</span> {
  <span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">bar</span>;
  <span class="org-keyword">public</span>: 
    <span class="org-function-name">Foo</span>(<span class="org-type">Foo</span>&amp; <span class="org-variable-name">f</span>) { bar = f.bar; }
}
</pre>
</div>

<p>
将复制构造函数声明为私有，可以避免 <a href="#excess_reclamation_bug">excess-reclamation bug</a>。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8-10" class="outline-3">
<h3 id="sec-8-10"><span class="section-number-3">8.10</span> 析构函数</h3>
<div class="outline-text-3" id="text-8-10">
<ul class="org-ul">
<li>名称为 <code>~</code> 前缀加类名。
</li>
<li>在类对象的内存被回收时调用：
<ul class="org-ul">
<li>使用 <code>delete</code> 运算符时。
</li>
<li>作为传值参数的函数返回时。
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-8-10-1" class="outline-4">
<h4 id="sec-8-10-1"><span class="section-number-4">8.10.1</span> 虚拟析构函数</h4>
<div class="outline-text-4" id="text-8-10-1">
<div class="org-src-container">
<label class="org-src-name">当使用多态，使用基类指针声明子类对象时，子类的析构函数无法被调用：</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Person</span>() { cout &lt;&lt; <span class="org-string">"Deleting person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Student</span>() { cout &lt;&lt; <span class="org-string">"Deleting student."</span>; }
};

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
<span class="org-keyword">delete</span> p; <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting person.</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">将基类中的析构函数声明为 <code>virtual</code> ，可以使基类和子类的析构函数都被调用：</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">Person</span>() { cout &lt;&lt; <span class="org-string">"Deleting person."</span>; }
};

<span class="org-keyword">class</span> <span class="org-type">Student</span> : <span class="org-keyword">public</span> <span class="org-type">Person</span> {
    <span class="org-keyword">public</span>:
        ~<span class="org-function-name">Student</span>() { cout &lt;&lt; <span class="org-string">"Deleting student."</span>; }
};

<span class="org-type">Person</span>* <span class="org-variable-name">p</span> = <span class="org-keyword">new</span> <span class="org-type">Student</span>;
<span class="org-keyword">delete</span> p; <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting student.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Deleting person.</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-11" class="outline-3">
<h3 id="sec-8-11"><span class="section-number-3">8.11</span> 函数原型</h3>
<div class="outline-text-3" id="text-8-11">
<dl class="org-dl">
<dt> Function prototype </dt><dd>A preview of a member function definition within the class definition. <br  />
                        Similar to a function definition but without a body. <br  />
                        The function can be defined elsewhere, outside of the class definition.
</dd>
</dl>

<div class="org-src-container">
<label class="org-src-name">声明</label>
<pre class="src src-cpp"><span class="org-keyword">class</span> &lt;<span class="org-type">Class</span>&gt; {
    <span class="org-keyword">public</span>: &lt;type&gt; &lt;function&gt;(&lt;type&gt;);
};
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">定义</label>
<pre class="src src-cpp">&lt;type&gt; &lt;Class&gt;::&lt;function&gt;(&lt;type&gt; &lt;param&gt;) { <span class="org-comment-delimiter">// </span><span class="org-comment">:: are called the class-scope operator</span>
    ...
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 程序</h2>
<div class="outline-text-2" id="text-9">
<p>
A good program
</p>
<ul class="org-ul">
<li>is decomposed logically into functions where any one function does one and only one task
</li>
<li>has a main program that reads like an outline of what the program will do
</li>
<li>has descriptive function, constant and variable names
</li>
<li>uses constants to avoid any "magic" numbers in the program
</li>
<li>has a friendly user interface
</li>
</ul>
</div>

<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 头文件</h3>
<div class="outline-text-3" id="text-9-1">
<p>
头文件向源码文件输出服务，即 <code>.cpp</code> 文件中 <code>#include</code> 头文件。
</p>

<p>
头文件包含：
</p>
<ul class="org-ul">
<li>类定义（成员变量、成员函数原型）
</li>
<li>全局变量声明
</li>
<li>普通（全局）函数原型
</li>
</ul>

<p>
头文件只包含声明，不包含定义（内存分配操作），因为头文件可能被多个文件加载，而变量和函数定义只能有一次。
</p>

<div class="org-src-container">
<label class="org-src-name">示例：=class.h=</label>
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Description: ...</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">myConst</span> = 1;

<span class="org-keyword">class</span> <span class="org-type">Class</span> {
  <span class="org-keyword">public</span>:
    <span class="org-function-name">Class</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor</span>
    ~<span class="org-function-name">Class</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor</span>

    <span class="org-type">void</span> <span class="org-function-name">set_attr</span>(<span class="org-type">string</span> <span class="org-variable-name">attr</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">Mutator</span>
    <span class="org-type">string</span> <span class="org-function-name">get_attr</span>();          <span class="org-comment-delimiter">// </span><span class="org-comment">Accessor</span>

    <span class="org-type">void</span> <span class="org-function-name">foo</span>();

  <span class="org-keyword">private</span>:
    <span class="org-type">string</span> <span class="org-variable-name">attr</span>;
}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#23614;&#38656;&#35201; ;</span>
</pre>
</div>

<hr  />

<p>
Header files such as <code>iostream.h</code> are for functions supplied by C++ standard library. When compiler links object files to create an executable program, it looks for the appropriate object code in a standard library file. The location of this standard library file generally is provided to the compiler when the compiler is installed.
</p>

<p>
Many C++ compilers bring every function mentioned in a header file into the program, even those functions that are not used. By creating multiple header files, a library's author makes it possible to use the library file selectively.
</p>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 源码文件</h3>
<div class="outline-text-3" id="text-9-2">
<div class="org-src-container">
<label class="org-src-name">示例：=class.cpp=</label>
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">"class.h"</span>

<span class="org-constant">Class</span>::<span class="org-function-name">Class</span>() {...}
<span class="org-type">void</span> <span class="org-constant">Class</span>::<span class="org-function-name">foo</span>() {...}
</pre>
</div>

<p>
在源码文件中加载相应的头文件，是为了确保函数定义和函数原型保持一致，在不一致时编译器会报错。
</p>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> 客户文件</h3>
<div class="outline-text-3" id="text-9-3">
<div class="org-src-container">
<label class="org-src-name">示例：=main.cpp=</label>
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">"class.h"</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">Class</span> <span class="org-variable-name">obj</span>;
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> <code>#include</code></h3>
<div class="outline-text-3" id="text-9-4">
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;file&gt;</span>
</pre>
</div>

<p>
<code>#include</code> 的效果相当于把被加载的文件内容加入到此处。
</p>

<p>
当加载的头文件用 <code>&lt;&gt;</code> 包围时，编译器会先在 C++ 标准库目录下查找，之后通常在当前目录下查找。
</p>

<p>
当加载的头文件用 <code>""</code> 包围时，编译器会先在当前目录下查找，之后通常在 C++ 标准库目录下查找。
</p>

<p>
一些编译器还支持在命令中加入自定义的查找目录。
</p>
</div>
</div>
<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> <code>main()</code></h3>
<div class="outline-text-3" id="text-9-5">
<p>
每个程序必须定义一个 <code>main()</code> 函数。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 编译</h2>
<div class="outline-text-2" id="text-10">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>.h</code></th>
<th scope="col" class="left">头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>.cpp</code></td>
<td class="left">源码文件</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left"><code>.o</code></td>
<td class="left">对象（object）文件</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 编译过程</h3>
<div class="outline-text-3" id="text-10-1">
<p>
编译器使用 <code>.h</code> 文件，将 <code>.cpp</code> 文件编译为 <code>.o</code> 文件，之后将 <code>.o</code> 文件链接（link）成为可执行文件。
</p>

<p>
「编译」比「链接」耗时。
</p>

<p>
When compiler links object files to create an executable program, it encounters functions for which it has seen function prototypes but no corresponding function definitions. Whenever that happens, the C++ compiler looks for the appropriate object code.
</p>


<div class="figure">
<p><img src="../images/c++/01.png" alt="01.png" />
</p>
</div>

<p>
当一个头文件被修改时，必须重新编译所有加载这个头文件的源码文件。
</p>

<div class="org-src-container">
<label class="org-src-name">当一个源码文件被修改时，只需要重新编译这个文件，并重新链接所有对象文件：</label>
<pre class="src src-sh">g++ -c foo.cpp
g++ -o exe foo.o bar.o baz.o
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 编译器</h3>
<div class="outline-text-3" id="text-10-2">
<p>
常用 C++ 编译器：CC，g++，cxx。
</p>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> <code>g++</code></h3>
<div class="outline-text-3" id="text-10-3">
<div class="org-src-container">

<pre class="src src-sh">g++ &lt;options&gt; &lt;file&gt;
    -o &lt;file&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">Place the output into &lt;file&gt;</span>
    -c        <span class="org-comment-delimiter"># </span><span class="org-comment">Compile and assembly, but do not link</span>
    -v
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">直接编译</label>
<pre class="src src-sh">$ g++ -Wall -W -Werror &lt;file&gt; -o &lt;file&gt;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name">脚本编译</label>
<pre class="src src-sh"><span class="org-comment-delimiter">## </span><span class="org-comment">/bin/gccp</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">/bin/sh</span>
<span class="org-builtin">echo</span> compiling C++ using -ansi -pedantic-errors -Wall
g++ -ansi -pedantic-errors -Wall $<span class="org-variable-name">1</span> $<span class="org-variable-name">2</span> $<span class="org-variable-name">3</span>

<span class="org-comment-delimiter">## </span><span class="org-comment">&#32534;&#35793;</span>
$ gccp &lt;file&gt; -o &lt;file&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> <code>make</code></h3>
<div class="outline-text-3" id="text-10-4">
<p>
不使用 <code>make</code>
</p>
<ul class="org-ul">
<li>需要在 <code>g++</code> 命令中列出所有源码文件，命令复杂，不容易保存和重复使用
</li>
<li>一个源码文件被修改后，需要重新编译所有文件，效率低
</li>
</ul>

<p>
使用 <code>make</code>
</p>
<ul class="org-ul">
<li>将源文件的依赖关系和编译命令写在 <code>makefile</code> 文件中，通过 <code>make</code> 命令执行编译
</li>
<li>当一个目标的依赖文件更新后， <code>make</code> 将会执行其后的所有命令行，以生成目标的新版本
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">make [&lt;options&gt;] [&lt;target&gt;]
    &lt;target&gt;  <span class="org-comment-delimiter"># </span><span class="org-comment">&#19981;&#25351;&#23450;&#26102;&#65292;&#23558;&#25191;&#34892; makefile &#20013;&#31532;&#19968;&#20010;&#30446;&#26631;&#30340;&#21629;&#20196;</span>
    -f &lt;file&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">&#25351;&#23450; makefile</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> <code>makefile</code></h3>
<div class="outline-text-3" id="text-10-5">
<p>
<code>makefile</code> 由多个条目组成，每个条目包含：
</p>
<ul class="org-ul">
<li>目标：通常是一个文件
</li>
<li>依赖：目标依赖的文件
</li>
<li>命令：编译目标的命令
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name">语法</label>
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Comment                  # &#27880;&#37322;</span>
&lt;target&gt;: &lt;dependency&gt; ... <span class="org-comment-delimiter"># </span><span class="org-comment">&#20381;&#36182;&#25991;&#20214;&#26356;&#26032;&#21518;&#65288;&#36890;&#36807;&#27604;&#36739;&#26102;&#38388;&#25139;&#65289;&#65292;&#25165;&#37325;&#26032;&#32534;&#35793;&#36825;&#20010;&#30446;&#26631;</span>
    &lt;command&gt;              <span class="org-comment-delimiter"># </span><span class="org-comment">&#38656;&#35201;&#20197; tab &#24320;&#22836;</span>
</pre>
</div>

<hr  />

<div class="org-src-container">
<label class="org-src-name"><code>target</code> 为可执行文件（通常是 <code>makefile</code> 中第一个目标）</label>
<pre class="src src-sh">exe: alpha.o beta.o gamma.o
    g++ -Wall alpha.o beta.o gamma.o -o exe
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>target</code> 为 <code>.o</code> 文件</label>
<pre class="src src-sh">alpha.o: alpha.cpp alpha.h beta.h <span class="org-comment-delimiter"># </span><span class="org-comment">alpha.cpp &#20381;&#36182;&#20110;&#65288;#include&#65289; beta.h</span>
    g++ -Wall -c alpha.cpp        <span class="org-comment-delimiter"># </span><span class="org-comment">&#20351;&#29992; -c &#36873;&#39033;&#21482;&#29983;&#25104; .o &#25991;&#20214;</span>

beta.h: gamma.h <span class="org-comment-delimiter"># </span><span class="org-comment">beta.h &#20381;&#36182;&#20110; gamma.h&#65292;&#22240;&#27492; alpha.o &#20063;&#20381;&#36182;&#20110; gamma.h</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">&#21333;&#29420;&#22768;&#26126;&#20256;&#36882;&#30340;&#65288;&#38750;&#30452;&#25509;&#30340;&#65289;&#20381;&#36182;&#65292;&#26356;&#31616;&#27905;&#65292;&#20063;&#36991;&#20813;&#36951;&#28431;</span>
</pre>
</div>

<hr  />

<div class="org-src-container">
<label class="org-src-name">macros</label>
<pre class="src src-sh">OBJS = src1.o src2.o
CC = g++
DEBUG = -g                 <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for debugging</span>
CFLAGS = -Wall -c $(DEBUG) <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for compiling</span>
LFLAGS = -Wall $(DEBUG)    <span class="org-comment-delimiter"># </span><span class="org-comment">Flags for linking</span>

p1: $(OBJS)
    $(CC) $(LFLAGS) $(OBJS) -o p1
</pre>
</div>

<hr  />

<p>
Dummy targets
</p>
<ul class="org-ul">
<li>used to run commands without creating targets
</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><code>make clean</code></label>
<pre class="src src-sh">clean:
    \rm *.o *~ exe <span class="org-comment-delimiter"># </span><span class="org-comment">&#21024;&#38500;&#25152;&#26377; .o &#25991;&#20214;&#12289;emacs &#22791;&#20221;&#25991;&#20214;&#12289;&#25351;&#23450;&#21487;&#25191;&#34892;&#25991;&#20214;</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>make tar</code></label>
<pre class="src src-sh">tar:
    tar cvf project.tar alpha.h alpha.cpp beta.h ...
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><code>make all</code></label>
<pre class="src src-sh">all: exe1 exe2 ... <span class="org-comment-delimiter"># </span><span class="org-comment">&#19968;&#27425;&#29983;&#25104;&#22810;&#20010;&#21487;&#25191;&#34892;&#25991;&#20214;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 链接</h2>
<div class="outline-text-2" id="text-11">
<ol class="org-ol">
<li><a href="http://en.cppreference.com/w/">cppreference.com</a>
</li>
<li><a href="http://www.cplusplus.com/reference/">cplusplus.com</a>
</li>
<li><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>
</li>
</ol>

<hr  />

<ol class="org-ol">
<li><a href="http://www.tutorialspoint.com/cplusplus/index.htm">C++ Tutorial</a>
</li>
<li><a href="http://www.learncpp.com/">Learn C++</a>
</li>
<li><a href="https://isocpp.org/faq">C++ FAQ</a>
</li>
</ol>

<hr  />

<ol class="org-ol">
<li><a href="http://www.gnu.org/software/make/manual/make.html">GNU make</a>
</li>
<li><a href="http://www.cs.umd.edu/class/fall2002/cmsc214/Tutorial/makefile.html">Makefiles</a>
</li>
<li><a href="http://people.engr.ncsu.edu/efg/210/s99/Notes/makefiles.html">Separate Compilation and Makefiles</a>
</li>
</ol>

<hr  />

<ol class="org-ol">
<li><a href="http://cpp.sh/">C++ Shell</a>
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2017-05-27 Sat 10:26</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5h)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
