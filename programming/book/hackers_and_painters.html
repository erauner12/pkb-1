<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Hackers and Painters</title>
<!-- 2016-10-04 周二 22:22 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/font.css"/>
<link rel="stylesheet" type="text/css" href="../../styles/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="../../styles/readtheorg/js/jquery.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Hackers and Painters</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 序言</a></li>
<li><a href="#sec-2">2. 前言</a></li>
<li><a href="#sec-3">3. 第一章</a></li>
<li><a href="#sec-4">4. 第二章</a></li>
<li><a href="#sec-5">5. 第三章</a></li>
<li><a href="#sec-6">6. 第四章</a></li>
<li><a href="#sec-7">7. 第五章</a></li>
<li><a href="#sec-8">8. 第六章</a></li>
<li><a href="#sec-9">9. 第七章</a></li>
<li><a href="#sec-10">10. 第八章</a></li>
<li><a href="#sec-11">11. 第九章</a></li>
<li><a href="#sec-12">12. 第十章</a></li>
<li><a href="#sec-13">13. 第十一章</a></li>
<li><a href="#sec-14">14. 第十二章</a></li>
<li><a href="#sec-15">15. 第十三章</a></li>
<li><a href="#sec-16">16. 第十四章</a></li>
<li><a href="#sec-17">17. 第十五章</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 序言</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
快速发布产品，因为这样可以尽早知道一个创意是否可行。
</p>

<p>
一定要特别关注用户需要什么，这样才有办法将一个坏项目转变成好项目。
</p>
</blockquote>

<blockquote>
<p>
许多伟大的公司，一开始的时候做的都是与后来业务完全不同的事情。
</p>
</blockquote>

<blockquote>
<p>
「所有的东西都在变成软件。印刷机诞生后，人类写过多少个字，未来就有多少家软件公司。」
</p>
</blockquote>

<blockquote>
<p>
「出于兴趣而解决某个难题，不管它有没有用，这就是黑客。」
</p>
</blockquote>

<blockquote>
<p>
「对于黑客来说，关着的门就是一种挑衅，而锁着的门则是一种侮辱。」
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 前言</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
为什么黑客那么在乎言论自由？我认为，部分原因在于，革新于软件行业实在是太重要了，而革新和异端实际上是同一件事。
</p>

<p>
Why do hackers care so much about free speech? Partly, I think, because innovation is so important in software, and innovation and heresy are practically the same thing.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 第一章</h2>
<div class="outline-text-2" id="text-3">
<p>
为什么书呆子不受欢迎（Why Nerds Are Unpopular）
</p>

<blockquote>
<p>
书呆子不受欢迎的真正原因，是他们脑子里想着别的事情。他们的注意力都放在读书或者观察世界上面，而不是放在穿衣打扮、开晚会上面。
</p>

<p>
The main reason nerds are unpopular is that they have other things to think about. Their attention is drawn to books or the natural world, not fashions and parties.
</p>
</blockquote>

<blockquote>
<p>
书呆子从小琢磨的却如何更聪明，这都是受父母的影响，书呆子被教导追求正确答案，而受欢迎的小孩被教导讨人喜欢。
</p>

<p>
The nerds learned to be smart, and to want to be smart: from their parents. While the nerds were being trained to get the right answers, the popular kids were being trained to please.
</p>
</blockquote>

<blockquote>
<p>
在任何社会等级制度中，那些对自己没自信的人就会通过虐待他们眼中的下等人来凸显自己的身份。正是因为这个原因，在美国社会中底层白人是对待黑人最残酷的群体。
</p>

<p>
In any social hierarchy, people unsure of their own position will try to emphasize it by maltreating those they think rank below. This is why poor whites in the United States are the group most hostile to blacks.
</p>
</blockquote>

<blockquote>
<p>
真实世界的特点是，它极其庞大。如果总体足够大，即使是人数最少的少数派，只要聚集在一起，也能产生可观的力量。
</p>

<p>
The real world is much larger. In a large enough pool, even the smallest minorities can achieve a critical mass if they clump together.
</p>
</blockquote>

<blockquote>
<p>
事实上，学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事情做完。
</p>

<p>
In fact the primary purpose of schools is to keep kids locked up in one place for a big chunk of the day so adults can get things done.
</p>
</blockquote>

<blockquote>
<p>
成年人对自己说，孩子们不快的原因是因为他们身体内部新出现了大量的化学物质——激素。整个社会系统一点问题也没有。
</p>

<p>
The reason kids are so unhappy, adults tell themselves, is that monstrous new chemicals, hormones. There’s nothing wrong with the system.
</p>
</blockquote>

<blockquote>
<p>
人类喜欢工作，在世界上大多数地方，你的工作就是你的身份证明。
</p>

<p>
Humans like to work; in most of the world, your work is your identity.
</p>
</blockquote>

<blockquote>
<p>
过去的社会中，青少年扮演着一个更积极的角色。工业化时代到来前，青少年都是某种形式的学徒，他们不会被扔到一旁，他们是成年人社会的低级成员。
</p>

<p>
Teenage kids used to have a more active role in society. In pre-industrial times, they were all apprentices of one sort or another. They weren’t left to create their own societies. They were junior members of adult societies.
</p>
</blockquote>

<blockquote>
<p>
如今的大多数青少年，对他们的家长在遥远的办公室所从事的工作几乎一无所知。他们看不到学校作业与未来走上社会后从事工作有何联系。
</p>

<p>
Now most kids have little idea what their parents do in their distant offices, and see no connection (indeed, there is precious little) between schoolwork and the work they’ll do as adults.
</p>
</blockquote>

<blockquote>
<p>
如今的成年人根本不接受青少年。一般来说，他们都是在办公室工作，所以就在上班的路上，顺路把孩子送到学校去关着，这有点像他们周末外出度假时，把狗送到寄养的地方。
</p>

<p>
Now adults have no immediate use for teenagers. They would be in the way in an office. So they drop them off at school on their way to work, much as they might drop the dog off at a kennel if they were going away for the weekend.
</p>
</blockquote>

<blockquote>
<p>
当今的青少年在生产活动中，根本就是毫无用处的。他们只能在诸如快餐店这样的地方充当廉价劳动力……对于除此以外的几乎所有行业，青少年都会带来净损失……最有效的解决方案，就是把他们集中在一个地方，用几个成年人看守所有小孩。
</p>

<p>
Teenagers now are useless, except as cheap labor in industries like fast food. In almost any other kind of work, they’d be a net loss. The most efficient way &#x2026; is to collect them together in one place. Then a few adults can watch all of them.
</p>
</blockquote>

<blockquote>
<p>
对于书呆子来说，意识到学校并非全部的人生，是很重要的事情。学校是一个很奇怪的、人为设计出来的体系，一半像是无菌室，一半像是野蛮洪荒之地。
</p>

<p>
It’s important for nerds to realize that school is not life. School is a strange, artificial thing, half sterile and half feral.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 第二章</h2>
<div class="outline-text-2" id="text-4">
<p>
黑客与画家（Hackers and Painters）
</p>

<blockquote>
<p>
黑客与画家的共同之处，在于他们都是创作者，都是试图创作出优秀的作品。
</p>

<p>
What hackers and painters have in common is that they're both makers. What hackers and painters are trying to do is make good things.
</p>
</blockquote>

<blockquote>
<p>
我一直不喜欢计算机科学这个词，主要原因是根本不存在这种东西。计算机科学就像个大杂烩，很多不相干的领域被强行拼装在一起。这个学科的一端是纯粹的数学家。中间部分是计算机博物学家，研究各种专门性的题目，比如网络数据的路由算法。另一端则是黑客，对于他们来说，计算机只是一种表达的媒介，就像建筑师手里的混凝土，或者画家手里的颜料。
</p>

<p>
I've never liked the term "computer science." The main reason I don't like it is that there's no such thing. Computer science is a grab bag of tenuously related areas thrown together by an accident of history, like Yugoslavia. At one end you have people who are really mathematicians. In the middle you have people working on something like the natural history of computers — studying the behavior of algorithms for routing data through networks, for example. And then at the other extreme you have the hackers, for whom computers are just a medium of expression, as concrete is for architects or paint for painters.
</p>
</blockquote>

<blockquote>
<p>
只是单纯地决定如何实现某种规格，那肯定不是黑客，黑客的最高境界是创造规格。
</p>

<p>
Hacking can certainly be more than just deciding how to implement some spec. At its best, it's creating the spec.
</p>
</blockquote>

<blockquote>
<p>
写过博士论文的人都知道，确保自己正在开垦新领地的方法，就是去找那些没有人要的土地。那些不成熟的、障碍重重的领域最容易写出许多篇论文，因为你可以写那些为了完成工作、你不得不克服的障碍。
</p>

<p>
As anyone who has written a PhD dissertation knows, the way to be sure you're exploring virgin territory is to stake out a piece of ground that no one wants. Awkward systems yield meatier papers, because you can write about the obstacles you have to overcome in order to get things done.
</p>
</blockquote>

<blockquote>
<p>
创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。
</p>

<p>
The way to create something beautiful is often to make subtle tweaks to something that already exists, or to combine existing ideas in a slightly new way.
</p>
</blockquote>

<blockquote>
<p>
设计优美的软件……唯一有效的外部考核就是时间。经过岁月的洗礼，优美的东西生存发展的机会更大，丑陋的东西往往会被淘汰。不幸的是，这种考核需要的时间可能比一个人的生命还要长。人们对一个作家的评价，需要100年才能达成一致。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。
</p>

<p>
Designing beautiful software &#x2026; The only external test is time. Over time, beautiful things tend to thrive, and ugly things tend to get discarded. Unfortunately, the amounts of time involved can be longer than human lifetimes. It took a hundred years for a writer's reputation to converge. You have to wait for the writer's influential friends to die, and then for all their followers to die.
</p>
</blockquote>

<blockquote>
<p>
我现在认为，大学里教给我的编程方法都是错的。你把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前。
</p>

<p>
As far as I can tell, the way they taught me to program in college was all wrong. You should figure out programs as you're writing them.
</p>
</blockquote>

<blockquote>
<p>
明白这一点对软件设计有重大影响，它意味着，编程语言首要的特性应该是允许动态扩展（malleable）。 <b>编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。</b>
</p>

<p>
Realizing this has real implications for software design. It means that a programming language should, above all, be malleable. A programming language is for thinking of programs, not for expressing programs you've already thought of.
</p>
</blockquote>

<blockquote>
<p>
大公司为了避免设计上的灾难，选择了减少设计结果的标准差。但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是他们的获胜手段。大公司只要做到不太烂，就能赢。
</p>

<p>
Big companies want to decrease the standard deviation of design outcomes because they want to avoid disasters. But when you damp oscillations, you lose the high points as well as the low. This is not a problem for big companies, because they don't win by making great products. Big companies win by sucking less than other big companies.
</p>
</blockquote>

<blockquote>
<p>
真正竞争软件设计的战场是新兴领域的市场，只要你能做出大胆的设计，由一个人或一批人同时负责设计和实现产品，你就能在这里战胜大公司。
</p>

<p>
The place to fight design wars is in new markets. That's where you can win big by taking the bold approach to design, and having the same people both design and implement the product.
</p>
</blockquote>

<blockquote>
<p>
如果你不爱一件事，你不可能把它做得真正优秀，要是你很热爱编程，你就不可避免地会开发你自己的项目。
</p>

<p>
You can't do anything really well unless you love it, and if you love to hack you'll inevitably be working on projects of your own.
</p>
</blockquote>

<blockquote>
<p>
画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。
</p>

<p>
You learn to paint mostly by doing it. Ditto for hacking.
</p>
</blockquote>

<blockquote>
<p>
黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。
</p>

<p>
Hackers, can learn to program by looking at good programs — not just at what they do, but at the source code.
</p>
</blockquote>

<blockquote>
<p>
坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。
</p>

<p>
Relentlessness wins because, in the aggregate, unseen details become visible.
</p>
</blockquote>

<blockquote>
<p>
如果一个代码块由三四个人共同开发，就没有人真正拥有这块代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。
</p>

<p>
When a piece of code is being hacked by three or four different people, no one of whom really owns it. The right way to collaborate, I think, is to divide projects into sharply defined modules, each with a definite owner, and with interfaces between them that are as carefully designed and, if possible, as articulated as programming languages.
</p>
</blockquote>

<blockquote>
<p>
大多数创作者都是为人类用户而创作。为了吸引用户，你必须理解用户需要什么。举例来说，几乎所有最伟大的绘画作品都是画人的，因为人类总是对自身感兴趣的。
</p>

<p>
Most makers make things for a human audience. And to engage an audience you have to understand what they need. Nearly all the greatest paintings are paintings of people, for example, because people are what people are interested in.
</p>
</blockquote>

<blockquote>
<p>
软件的部分功能就是解释自身。为了写出优秀软件，你必须假定用户对你的软件基本上一无所知。你要明白，用户第一次使用你的软件的时候，不会预先做好功课，他们没有任何准备就开始用了，所以软件的使用方式最好能符合用户的直觉，别指望用户去读使用手册。
</p>

<p>
Part of what software has to do is explain itself. So to write good software you have to understand how little users understand. They're going to walk up to the software with no preparation, and it had better do what they guess it will, because they’re not going to read the manual.
</p>
</blockquote>

<blockquote>
<p>
<b>「程序写出来是给人看的，附带能在机器上运行。」</b>
</p>

<p>
Programs should be written for people to read, and only incidentally for machines to execute.
</p>
</blockquote>

<blockquote>
<p>
我们看到这种模式一再反复出现。一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。编程目前好像就处在这个阶段。
</p>

<p>
Over and over we see the same pattern. A new medium appears, and people are so excited about it that they explore most of its possibilities in the first couple generations. Hacking seems to be in this phase now.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 第三章</h2>
<div class="outline-text-2" id="text-5">
<p>
不能说的话（What You Can't Say）
</p>

<blockquote>
<p>
历史的常态似乎就是，任何一个年代的人们，都会对一些荒谬的东西深信不疑。
</p>

<p>
It seems to be a constant throughout history: in every period, people believed things that were just ridiculous.
</p>
</blockquote>

<blockquote>
<p>
触怒他人的言论是那些可能会有人相信的言论。
</p>

<p>
I suspect the statements that make people maddest are those they worry might be true.
</p>
</blockquote>

<blockquote>
<p>
伽利略因为宣传日心说而遭到教廷的审判，这件事讽刺的地方在于，他只是在宣传哥白尼的观点，而后者却安然无恙。
</p>

<p>
The irony of Galileo's situation was that he got in trouble for repeating Copernicus's ideas. Copernicus himself didn't.
</p>
</blockquote>

<blockquote>
<p>
想要做出优秀的作品，你需要一个什么问题都能思考的大脑，尤其是那些似乎不应该思考的问题。
</p>

<p>
To do good work you need a brain that can go anywhere. And you especially need a brain that's in the habit of going where it's not supposed to.
</p>
</blockquote>

<blockquote>
<p>
大学中的一个大忌——评判各种学科的难易。大学校园中有一条默认的公理——各种领域的研究所要求的智力水平都是相同的。
</p>

<p>
&#x2026; the principal taboo of university life. Within universities it's an unspoken axiom that all areas of study are intellectually equal.
</p>
</blockquote>

<blockquote>
<p>
自由思考比畅所欲言更重要。在心里无所不想，但是不一定要说出来。「不能说的话」太多了，如果口无遮拦，你就没时间做正事了。
</p>

<p>
The most important thing is to be able to think what you want, not to say what you want. Inside your head, anything is allowed. The problem is, there are so many things you can't say. If you said them all you'd have no time left for your real work.
</p>
</blockquote>

<blockquote>
<p>
能够一起谈论「异端邪说」并且不会因此气急败坏的人，就是你最应该认识的朋友。
</p>

<p>
The people you can say heretical things to without getting jumped on are also the most interesting to know.
</p>
</blockquote>

<blockquote>
<p>
你的策略，简单说，就是不赞同这个时代的任何一种歇斯底里，但是又不明确告诉别人到底不赞同哪一种歇斯底里。
</p>

<p>
Perhaps the best policy is to make it plain that you don't agree with whatever zealotry is current in your time, but not to be too specific about what you disagree with.
</p>
</blockquote>

<blockquote>
<p>
所有反击方法之中，最好的一种可能就是幽默。狂热分子都有一个共同点：缺乏幽默感。
</p>

<p>
Best (way to counterattack) of all, probably, is humor. Zealots, whatever their cause, invariably lack a sense of humor.
</p>
</blockquote>

<blockquote>
<p>
人们都会说同样的话：「我们心态很开放，愿意接受新思想。」但是实际上，人们脑子里有一根界线，早就认准了什么是对的，什么试错的。
</p>

<p>
Ask anyone, and they'll say the same thing: they're pretty open-minded, though they draw the line at things that are really wrong.
</p>
</blockquote>

<blockquote>
<p>
如果一个命题是错的，这就是它所能得到的最坏评价，足够批判它了，根本不用再加上其他任何标签。但是如果一个命题不是错的，却被加上各种标签，进行压制和批判，那就有问题。
</p>

<p>
If a statement is false, that's the worst thing you can say about it. You don’t need to say that it’s heretical. And if it isn't false, it shouldn't be suppressed.
</p>
</blockquote>

<blockquote>
<p>
如果你想要清晰地思考，就必须远离人群。
</p>

<p>
You have to take that extra step if you want to think clearly.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 第四章</h2>
<div class="outline-text-2" id="text-6">
<p>
良好的坏习惯（Good Bad Attitude）
</p>

<blockquote>
<p>
黑客是不服从管教的，这就是他们的本性。硅谷出现在美国，而不是法国、德国、英国、日本，这绝非偶然。后面那些国家的人们总是按部就班地行事。
</p>

<p>
Hackers are unruly. That is the essence of hacking. It is no accident that Silicon Valley is in America, and not France, or Germany, or England, or Japan. In those countries, people color inside the lines.
</p>
</blockquote>

<blockquote>
<p>
佛罗伦萨之所以著名，完全是因为这个城市在1450年的显赫地位，它是那时的纽约，形形色色疯狂而有抱负的人们来到这里。现在，这样的人都去了美国。
</p>

<p>
The reason Florence is famous is that in 1450, it was New York. In 1450 it was filled with the kind of turbulent and ambitious people you find now in America.
</p>
</blockquote>

<blockquote>
<p>
一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。
</p>

<p>
A society in which people can do and say what they want will also tend to be one in which the most efficient solutions win, rather than those sponsored by the most influential people.
</p>
</blockquote>

<blockquote>
<p>
政府侵犯公民自由，表面上看，并不会让程序员的代码质量下降。它只是逐渐地导致一个错误观点占上风的世界。
</p>

<p>
The government spying on people doesn't literally make programmers write worse code. It just leads eventually to a world in which bad ideas will win.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 第五章</h2>
<div class="outline-text-2" id="text-7">
<p>
另一条路（The Other Road Ahead）
</p>

<blockquote>
<p>
应用服务供应商( Application Service Provider)，简称ASP。
</p>
</blockquote>

<blockquote>
<p>
汽车诞生的头二三十年，你想当车主，非得成为汽车专家不可。计算机现在就处在这个阶段。一旦拥有了桌面电脑，你就被迫不情愿地学习很多东西，了解它的内部运作机制。
</p>

<p>
For the first twenty or thirty years, you had to be a car expert to own a car. Computers are in this phase now. When you own a desktop computer, you end up learning a lot more than you wanted to know about what's happening inside it.
</p>
</blockquote>

<blockquote>
<p>
使用互联网软件，除了软件本身，大多数用户不需要知道别的事情。所有那些乱七八糟、经常变动的东西，都放在服务器端，由精通此道的专业人员维护。
</p>

<p>
With web-based software, most users won’t have to think about anything except the applications they use. All the messy, changing stuff will be sitting on a server somewhere, maintained by the kind of people who are good at that kind of thing.
</p>
</blockquote>

<blockquote>
<p>
大多数人，在大多数时候，总是选择最省事的做法。如果互联网软件能够击败桌面软件，一定是赢在更方便这一优势上。
</p>

<p>
Most people, most of the time, will take whatever choice requires least work. If web-based software wins, it will be because it’s more convenient.
</p>
</blockquote>

<blockquote>
<p>
「你的电脑」这个概念正慢慢成为过去时，取而代之的是「你的数据」。
</p>

<p>
The whole idea of “your computer” is going away, and being replaced with “your data.”
</p>
</blockquote>

<blockquote>
<p>
对于互联网软件来说，大部分的变化都是细微和渐进的，所以引入 bug 的机会比较小。而且，在发布前测试的时候，你知道应该最仔细地测试哪个部分—显然就是你修改过的部分。
</p>

<p>
With server-based software, most of the change is small and incremental. That in itself is less likely to introduce bugs. It also means you know what to test most carefully when you’re about to release software: the last thing you changed.
</p>
</blockquote>

<blockquote>
<p>
互联网软件的另一个技术优势在于，你能再现大部分的 bug。
</p>

<p>
The other major technical advantage of web-based software is that you can reproduce most bugs.
</p>
</blockquote>

<blockquote>
<p>
互联网软件每时每刻都在被使用。你的代码一上线，就会经历严酷考验。bug 很快就会浮出水面。
</p>

<p>
Web-based software gets used round the clock, so everything you do is immediately put through the wringer. Bugs turn up quickly.
</p>
</blockquote>

<blockquote>
<p>
……我们才意识到客户支持实际上就是质量监控，也是某种程度的市场营销。除了记录 bug，客服人员还必须大概了解相关知识，回答与bug相关的一些问题、解释令使用者迷惑不解的功能等。有时，他们也扮演了使用者的代理人，我们会问他们哪个新功能是用户更想要的，他们总是能做出正确的回答。
</p>

<p>
&#x2026; we realized they were effectively QA and to some extent marketing as well. In addition to catching bugs, they were the keepers of the knowledge of vaguer, buglike things, like features that confused users. They were also a kind of proxy focus group; we could ask them which of two new features users wanted more, and they were always right.
</p>
</blockquote>

<blockquote>
<p>
构思这种东西有一个特点，那就是它会导致更多的构思。你有没有注意过，坐下来写东西的时候，一半的构思是写作时产生的？软件也是这样。实现某个构思，会带来更多的构思。
</p>

<p>
The thing about ideas, though, is that they lead to more ideas. Have you ever noticed that when you sit down to write something, half the ideas that end up in it are ones you thought of while writing? The same thing happens with software. Working to implement one idea gives you more ideas.
</p>
</blockquote>

<blockquote>
<p>
提高软件可靠性的关键在于开发时全神贯注，而不是降低开发速度。
</p>

<p>
Paying attention is more important to reliability than moving slowly.
</p>
</blockquote>

<blockquote>
<p>
所谓「人月」就是一个人在一个月内所能完成的工作量。假如某个项目预估需要 12 个人月，那么派 4 个人处理这个项目，理论上需要 3 个月，派 6 个人则只需要 2 个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短t期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加入力到该项目中，并不会加快进度，反而有可能使进度更加延后。
</p>
</blockquote>

<blockquote>
<p>
只要你还在很活跃地开发产品，就免不了要亲自做系统管理。如果你梦想写完代码，向服务器递交（check in），然后就可以回家，一天工作结束，这在互联网软件身上肯定没有实现的可能。互联网软件是活的，每时每刻都在你的服务器上运行。
</p>

<p>
&#x2026; to worry about the servers as long as you’re still actively developing the product. Web-based software is never going to be something you write, check in, and go home. It’s a live thing, running on your servers right now.
</p>
</blockquote>

<blockquote>
<p>
互联网软件能够让你前所未有地了解用户行为。
</p>

<p>
Server-based software gives you unprecedented information about their behavior.
</p>
</blockquote>

<blockquote>
<p>
效率对互联网软件至关重要，因为硬件费用由你支付。你的资本支出成本除以服务器所能支持的最大用户数量，就是你为每个用户付出的成本。如果你的软件效率高，你就能比同样硬件配置的竞争对手多发展用户，获得更多的利润。
</p>

<p>
Efficiency matters for server-based software, because you’re paying for the hardware. The number of users you can support per server is the divisor of your capital cost, so if you can make your software very efficient, you can undersell competitors and still make a profit.
</p>
</blockquote>

<blockquote>
<p>
……在那个地方加了一条提示，告诉用户已经接近终点了，提醒他们不要点击「后退」按钮。
</p>

<p>
&#x2026; added a message at that point, telling users they were nearly finished, and reminding them not to click on the Back button.
</p>
</blockquote>

<blockquote>
<p>
互联网软件不可能用自由软件的模式经营，只能由商业性公司来经营。因为经营互联网软件要承担很大的风险，会产生大量支出，没有人会免费做这件事情的。
</p>

<p>
Hosting applications is an area where companies will play a role that is not likely to be filled by freeware. Hosting applications is a lot of stress, and has real expenses. No one will want to do it for free.
</p>
</blockquote>

<blockquote>
<p>
你也不会有坏账的烦恼，如果谁不付钱，你就停止对他的服务。此外，你也不可能遇到盗版问题。
</p>

<p>
You have no trouble with uncollectible bills; if someone won’t pay, you can just turn off the service. And there is no possibility of piracy.
</p>
</blockquote>

<blockquote>
<p>
没有盗版是一种「优势」，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些。
</p>

<p>
That last “advantage” may turn out to be a problem. Some amount of piracy is to the advantage of software companies. If some user would never have bought your software at any price, you haven’t lost anything if he uses a pirated copy. In fact you gain, because he is one more user helping to make your software the standard.
</p>
</blockquote>

<blockquote>
<p>
软件公司明白这个道理，所以故意对某些盗版行为睁一只眼闭一只眼。由于互联网软件无法盗版，所以软件公司必须想出其他策略推广软件。
</p>

<p>
Software companies understand this and deliberately turn a blind eye to some kinds of piracy. With server-based software they will have to come up with some other solution.
</p>
</blockquote>

<blockquote>
<p>
有些服装品牌的目标客户是「都市青少年」，这些品牌的专卖店对店内偷窃行为就睁一只眼闭一只眼，因为它们的目标市场中，那些在店内行窃的「顾客」也是流行风尚的带头人，可能会带动本品牌的销售。
</p>

<p>
Clothing brands favored by “urban youth” do not try too hard to prevent shoplifting because in their target market the shoplifters are also the fashion leaders.
</p>
</blockquote>

<blockquote>
<p>
你可能认为，购买商品时，人们是先做出决定，然后再购买。事实上，第二步对第一步有反作用，如果某样商品购买起来很困难，人们就会改变主意，放弃购买。反过来也成立，如果某样东西易于购买，你就会多买一点。
</p>

<p>
You might think that people decide to buy something, and then buy it. In fact the second step can propagate back into the first: if something is hard to buy, people will change their mind about whether they wanted it. And vice versa: you’ll sell more of something when it’s easy to buy.
</p>
</blockquote>

<blockquote>
<p>
「边际成本」是一个经济学概念，指下一个单位产品的生产成本。软件的边际成本就是复制代码的成本，所以接近零。这意味着，对软件公司来说，增加 1 个用户几乎没有增加生产成本。它与价格歧视的关系在于，边际成本越低，厂商的定价空间就越大，它可以针对特定消费者定出很低的价格，从而达到扩大销售、利润最大化的目的。
</p>
</blockquote>

<blockquote>
<p>
把个人和小企业当作目标客户。这些客户决策比较灵活，又需要低成本的新技术，所以他们更愿意尝试新事物。
</p>

<p>
(Customers) were initially individuals and smaller companies. These are the users who are ready to try new things, partly because they’re more flexible, and partly because they want the lower costs of new technology.
</p>
</blockquote>

<blockquote>
<p>
反对者往往声称互联网软件不安全。但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？如果你想把钱藏在安全的地方，请问你是选择放在家中床垫下面，还是放在银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理，备份等。
</p>

<p>
The argument against this approach usually hinges on security. In fact the data was almost certainly safer in our hands than theirs. Who can hire better people to manage security, a technology startup whose whole business is running servers, or a clothing retailer? If you want to keep your money safe, do you keep it under your mattress at home, or put it in a bank? This argument applies to every aspect of server administration: not just security, but uptime, bandwidth, load management, backups, etc.
</p>
</blockquote>

<blockquote>
<p>
要让员工表现优秀，必须有竞争压力。销售员必须面对消费者，程序员必须面对竞争对手的软件，但是内部系统管理员就像老年单身汉，能够激励他的外部压力几乎没有。公司内部所有不直接感受到竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。
</p>

<p>
&#x2026; competitive pressure. A salesman has to deal with customers, and a developer has to deal with competitors’ software, but a system administrator, like an old bachelor, has few external forces to keep him in line. Outsource any job that’s not directly exposed to competitive pressure, because outsourcing it will thereby expose it to competitive pressure.
</p>
</blockquote>

<blockquote>
<p>
有钱的客户倾向于更贵的选择，即使便宜的选择更符合他们的需要，他们也不会买。原因就是，那些所有高价的人将更多的钱投入推销。大公司付出的高价之中，很大一部分是商家为了让大公司买下这个商品而付出的费用。
</p>

<p>
There is always a tendency for rich customers to buy expensive solutions, even when cheap solutions are better, because the people offering expensive solutions can spend more to sell them. A large part of what big companies pay extra for is the cost of selling expensive things to them.
</p>
</blockquote>

<blockquote>
<p>
如果 Mac 电脑真那么出色，为什么后来它的市场表现不佳？还是那个老生常谈的原因：成本太高。微软公司把所有精力都集中在软件上面，所以很多厂商只要专攻硬件就可以了，把硬件成本降了下来。单雏是微软的软件或者第三方厂商的硬件都不楚以赢得市场优势，但是它们结合起来，就在个人电脑出现后一段关键时期中主导了市场。苹果公司同时做软件和硬件，所以成本上没有优势。
</p>

<p>
If the Mac was so great, why did it lose? Cost, again. Microsoft concentrated on the software business and unleashed a swarm of cheap component suppliers on Apple hardware. It did not help, either, that suits took over during a critical period.
</p>
</blockquote>

<blockquote>
<p>
纵观创业公司的历史，你会发现它们变得越来越小，越来越快，越来越不像正规的企业。1960 年，所谓「开发软件」就是 IBM 公司的那种形式，满满一屋子的人，他们都戴着牛角质眼镜架，系着细细黑黑的领带，勤勉地埋头写代码，每人每天可以完成十行。到了 1980 年，「开发软件」变成了 8 到 10 人的一个小组，他们穿着牛仔裤上班，在 VT100 终端上打字。现在，「开发软件」则是两个人坐在客厅里，一人捧一台笔记本电脑。
</p>

<p>
Over time the teams have gotten smaller, faster, and more informal. In 1960, software development meant a roomful of men with horn-rimmed glasses and narrow black neckties, industriously writing ten lines of code a day on IBM coding forms. In 1980, it was a team of eight to ten people wearing jeans to the office and typing into VT100s. Now it’s a couple of guys sitting in a living room with laptops.
</p>
</blockquote>

<blockquote>
<p>
网页作为用户界面，功能实在是太弱了。不过必须指出，目前阶段的网页刚好能满足需要。
</p>

<p>
&#x2026; the lameness of web pages as a UI.  What matters, though, is that web pages are just good enough.
</p>
</blockquote>

<blockquote>
<p>
由于互联网软件的程序员非常辛苦，所以会使得经济优势根本性地从大公司向创业公司转移。互联网软件要求的那种T作强度和付出，只有当公司是其本人所有时，程序员才愿意提供。软件公司可以雇到能干的人，让他们去干轻松的事情，也可以雇到不能干的人，让他们去干艰苦的事情，但是无法雇到非常能干的人，让他们去干非常艰苦的事情。因为互联网软件的创业不需要太多的资本，所以大公司可以与创业公司竞争的优势就所剩无几了。
</p>

<p>
Server-based software is so hard on the programmers, it causes a fundamental economic shift away from large companies. It requires the kind of intensity and dedication from programmers that they will only be willing to provide when it’s their own company. Software companies can hire skilled people to work in a not-too-demanding environment, and can hire unskilled people to endure hardships, but they can’t hire highly skilled people to bust their asses. Since capital is no longer needed, big companies have little to bring to the table.
</p>
</blockquote>

<blockquote>
<p>
如何做出用户喜欢的产品。从制造简洁的产品开始着手，首先要保证你自己愿意使用。然后，迅速地做出 1.0 版，并且不断加以改进，整个过程中密切倾听用户的反馈。用户总是对的，但是不同的用户要求不一样。低端的用户要求简化操作和清晰易懂，高端的用户要求你增加新功能。
</p>

<p>
As for building something users love. Start by making something clean and simple that you would want to use yourself. Get a version 1.0 out fast, then continue to improve the software, listening closely to users as you do. The customer is always right, but different customers are right about different things; the least sophisticated users show you what you need to simplify and clarify, and the most sophisticated tell you what features you need to add.
</p>
</blockquote>

<blockquote>
<p>
几个黑客搞懂如何租用办公室，或者如何雇用销售人员，要比那些公司（不管大公司还是小公司）搞懂如何正确写出软件容易得多。
</p>

<p>
It’s a lot easier for a couple of hackers to figure out how to rent office space or hire sales people than it is for a company of any size to get software written.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 第六章</h2>
<div class="outline-text-2" id="text-8">
<p>
如何创造财富（How to Make Wealth）
</p>

<blockquote>
<p>
从经济学观点看，你可以把创业想象成一个压缩过程，你的所有工作年份被压缩成了短短几年。你不再是低强度地工作四十年，而是以极限强度工作四年。在高技术领域，这种压缩的回报尤其丰厚，工作效率越高，额外报酬就越高。
</p>

<p>
Economically, you can think of a startup as a way to compress your whole working life into a few years. Instead of working at a low intensity for forty years, you work as hard as you possibly can for four. This pays especially well in technology, where you earn a premium for working fast.
</p>
</blockquote>

<blockquote>
<p>
……当你打扰黑客让他们从屏幕前扭过头回答问题时，他们会恶狠狠地盯着你的原因。他们大脑内部精心构建的精巧建筑，瞬间就崩溃了。
</p>

<p>
&#x2026; hackers give you such a baleful stare as they turn from their screen to answer your question. Inside their heads a giant house of cards is tottering.
</p>
</blockquote>

<blockquote>
<p>
微软公司碰巧是历史上最大商业错误之一——DOS操作系统的授权协议——的受益者。如果 IBM 按照常理要求独家购买微软的产品，不许微软向第三方提供，微软也只能乖乖地签字。结果却是，IBM 尽全力帮助微软控制了个人电脑的标准。
</p>

<p>
Microsoft happens to have been the beneficiary of one of the most spectacular blunders in the history of business: the licensing deal for DOS. If IBM had required an exclusive license, as they should have, Microsoft would still have signed the deal. Instead IBM ended up using all its power in the market to give Microsoft control of the PC standard.
</p>
</blockquote>

<blockquote>
<p>
财富存在的时间与人类历史一样长久，甚至更长久。我们需要的东西就是财富，食品、服装、住房、汽车、生活用品、外出旅行等都是财富。金钱不是财富，而只是我们用来转移财富所有权的东西。
</p>

<p>
Wealth is as old as human history. Far older, in fact. Wealth is stuff we want: food, clothes, houses, cars, gadgets, travel to interesting places, and so on. Money is not wealth. It’s just something we use to move wealth around.
</p>
</blockquote>

<blockquote>
<p>
金钱是专业化的副产品。在一个高度分工的社会，你需要的大部分产品无法自己制造。
</p>

<p>
Money is a side effect of specialization. In a specialized society, most of the things you need, you can’t make for yourself.
</p>
</blockquote>

<blockquote>
<p>
交换媒介的缺点是，它往往模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介，让大家可以更方便地获得自己想要的东西。大多数生意的目的是为了创造财富，做出人们真正需要的东西。
</p>

<p>
The disadvantage of a medium is that it tends to obscure what trade really means. People think that what a business does is make money. But money is just the intermediate stage—just a shorthand—for whatever people want. What most businesses really do is make wealth. They do something people want.
</p>
</blockquote>

<blockquote>
<p>
大多数情况下，世界上可供交换的财富不是一个恒定不变的量。人类历史上的财富一直在不停地增长和毁灭（总体上看是净增长）。通过修理一辆老爷车，你使得自己更富有。与此同时，你也并没有使得任何人更贫穷。所以，这里明显不是一个面积不变的大饼。
</p>

<p>
There is not a fixed amount of wealth in the world. Wealth has been getting created and destroyed (but on balance, created) for all of human history. In restoring your old car you have made yourself richer. You haven’t made anyone else poorer. So there is obviously not a fixed pie.
</p>
</blockquote>

<blockquote>
<p>
随着工业化时代的来临，手工艺人越来越少。日前还存在的最大的手工艺人群体就是程序员。
</p>

<p>
With the rise of industrialization there are fewer and fewer craftsmen. One of the biggest remaining groups is computer programmers.
</p>
</blockquote>

<blockquote>
<p>
公司就是许多人聚在一起创造财富的地方，能够制造更多人们需要的东西。当然，有些雇员并不直接参与制造过程，但是程序员不然。他们真正地面对产品，一行行地写代码把产品做出来。
</p>

<p>
Everyone in a company works together to create wealth, in the sense of making more things people want. Many of the employees work at one remove from the actual making of stuff. Not the programmers. They literally think the product, one line at a time.
</p>
</blockquote>

<blockquote>
<p>
这就是为什么如此之多的最优秀程序员都是自由主义者的原因。我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。许许多多不创造任何财富的人――比如本科生、记者和政客――一听到最富有的 5% 人口占有全社会一半以上的财富，往往会认定这是不公平的。一个有经验的程序员很可能也认为这是不公平的。因为最顶尖的 5% 的程序员写出了全世界 99% 的优秀软件。
</p>

<p>
This is why so many of the best programmers are libertarians. In our world, you sink or swim, and there are no excuses. When those far removed from the creation of wealth—undergraduates, reporters, politicians—hear that the richest 5% of the people have half the total wealth, they tend to think injustice! An experienced programmer would be more likely to think is that all? The top 5% of programmers probably write 99% of the good software.
</p>
</blockquote>

<blockquote>
<p>
财富就意味着人们需要的东西，那么把商品送到顾客手中也是人们需要的。许许多多不生产物质商品的公司都是在如此创造财富。
</p>

<p>
If wealth means what people want, companies that move things also create wealth. Ditto for many other kinds of companies that don’t make anything physical.
</p>
</blockquote>

<blockquote>
<p>
你需要去做一些人们需要的东西。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。
</p>

<p>
You need to start doing something people want. You don’t need to join a company to do that. All a company is is a group of people working together to do something people want. It’s doing something people want that matters, not joining the group.
</p>
</blockquote>

<blockquote>
<p>
大公司会使得每个员工的贡献平均化，这是一个问题。大公司最大的困扰就是无法准确测量每个员工的贡献。如果一家公司真正能够按照贡献付薪，它将取得巨大成功。许多雇员会更努力地工作。更重要的是，这样一家公司将吸引那些工作特别努力的人，从而超越竞争对手。
</p>

<p>
That averaging gets to be a problem. I think the single biggest problem afflicting large companies is the difficulty of assigning a value to each person’s work. A company that could pay all its employees so straightforwardly would be enormously successful. Many employees would work harder if they could get paid for it. More importantly, such a company would attract people who wanted to work especially hard. It would crush its competitors.
</p>
</blockquote>

<blockquote>
<p>
要致富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。
</p>

<p>
To get rich you need to get yourself in a situation with two things, measurement and leverage. You need to be in a position where your performance can be measured, or there is no way to get paid more by doing more. And you have to have leverage, in the sense that the decisions you make have a big effect.
</p>
</blockquote>

<blockquote>
<p>
有一个办法可以发现是否存在可放大性，那就是看失败的可能性。因为收入和风险是对称的，所以如果有巨大的获利可能，就必然存在巨大的失败可能。如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。
</p>

<p>
A good hint to the presence of leverage is the possibility of failure. Upside must be balanced by downside, so if there is big potential for gain there must also be a terrifying possibility of loss. If you’re in a job that feels safe, you are not going to get rich, because if there is no danger there is almost certainly no leverage.
</p>
</blockquote>

<blockquote>
<p>
大公司就像巨型的古罗马战舰，一千个划船手共同划桨，推动它前进。但是，两个因素使得它快不起来。一个凶素是，每个划船手看不到自己更努力划桨有何不同，另一个因素是，一千人的团队使得任何个人的努力都被大大地平均化了。
</p>

<p>
A big company is like a giant galley driven by a thousand rowers. Two things keep the speed of the galley down. One is that individual rowers don’t see any result from working harder. The other is that, in a group of a thousand people, the average rower is likely to be pretty average.
</p>
</blockquote>

<blockquote>
<p>
这就是创业公司的真正意义。理想情况下，你与其他愿意更努力工作的人一起组成一个团队，共同谋取更高的回报。
</p>

<p>
That’s the real point of startups. Ideally, you are getting together with a group of other people who also want to work a lot harder, and get paid a lot more.
</p>
</blockquote>

<blockquote>
<p>
回顾历史，大多数因为创造财富而发财的人都是通过开发新技术而实现的。13 世纪，佛罗伦萨人发明了精纺布，这种新技术造就了佛罗伦萨的繁荣。17 世纪，荷兰人掌握了造船术和航海知识，因此荷兰人主宰了欧洲前往远东的航线。
</p>

<p>
If you look at history, it seems that most people who got rich by creating wealth did it by developing new technology. What made the Florentines rich in 1200 was the discovery of new techniques for making the high-tech product of the time, fine woven cloth. What made the Dutch rich in 1600 was the discovery of shipbuilding and navigation techniques that enabled them to dominate the seas of the Far East.
</p>
</blockquote>

<blockquote>
<p>
技术的发明人往往很难确定，可以明确无误地确认只有一个发明人很难。所以根据这条规则，如果你知道某种东西的发明人（比如电话、流水线，飞机、电灯，晶体管），那是因为他的公司用这种发明赚到了钱，并且公司公关人员尽力散布发明人的故事。如果你不知道谁发明了某种东西（汽车、电视、计算机、飞机引擎、激光），那是因为其他人的公司从这种发明中赚到了钱。
</p>

<p>
Few technologies have one clear inventor. So as a rule, if you know the “inventor” of something (the telephone, the assembly line, the airplane, the light bulb, the transistor) it is because their company made money from it, and the company’s PR people worked hard to spread the story. If you don’t know who invented something (the automobile, the television, the computer, the jet engine, the laser), it’s because other companies made all the money.
</p>
</blockquote>

<blockquote>
<p>
设置「进入壁垒」的方法之一就是申请专利。但是专利的保护程度可能不高。竞争对手通常能找到绕过专利的方法。如果找不到，它们可能就不找了，直接侵犯你的专利，等着你去起诉它们。大公司不害怕打官司，这对它们是家常便饭。
</p>

<p>
One way to put up barriers to entry is through patents. But patents may not provide much protection. Competitors commonly find ways to work around a patent. And if they can’t, they may simply violate it and invite you to sue them. A big company is not afraid to be sued; it’s an everyday thing for them.
</p>
</blockquote>

<blockquote>
<p>
一家大到有能力收购其他公司的公司必然也是一家大到变得很保守的公司，而这些公司内部负责收购的人又比其他人更保守，因为他们多半是从商学院毕业的，没有经历过公司的创业期。他们宁愿花大钱做更安全的选择，所以向他们出售一家已经成功的创业公司要比出售还处在早期阶段的创业公司更容易，即使会让他们付出多得多的价码。
</p>

<p>
A company big enough to acquire startups will be big enough to be fairly conservative, and within the company the people in charge of acquisitions will be among the more conservative, because they are likely to be business school types who joined the company late. They would rather overpay for a safe choice. So it is easier to sell an established startup, even at a large premium, than an early-stage one.
</p>
</blockquote>

<blockquote>
<p>
大多数时候，促成买方掏钱的最好办法不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是看到竞争对手可能收购你。
</p>

<p>
For most people, the most powerful motivator is not the hope of gain, but the fear of loss. For potential acquirers, the most powerful motivator is the prospect that one of their competitors will buy you.
</p>
</blockquote>

<blockquote>
<p>
……归根结底的因素都是用户数量。你以为买家在收购前会做很多研究，搞清楚你的公司到底值多少钱，其实根本不是这么回事。他们真正在意的只是你拥有的用户数量。
</p>

<p>
&#x2026; what it all comes down to is users. You’d think that a company about to buy you would do a lot of research and decide for themselves how valuable your technology was. Not at all. What they go by is the number of users you have.
</p>
</blockquote>

<blockquote>
<p>
创造人们需要的东西，也就是创造财富。如果你想通过创造财富使得自己致富，那么你必须知道人们需要什么。
</p>

<p>
Wealth is what people want. If you plan to get rich by creating wealth, you have to know what people want.
</p>
</blockquote>

<blockquote>
<p>
创造财富不是致富的唯一方法。在人类的历史长河中，它甚至不是最常见的方法。就在几个世纪前，快速获得财富的方法只有继承，婚姻、征服、没收。从那时到现在，两件事情出现了变化。第一个变化是法律。在相当长的历史时期内，你的财富得不到保护，统治者和他的手下可以设法将它占为已有。但是，变化出现在中世纪的欧洲。新兴的商人和制造业者开始在城市中崛起。他们团结起来对抗当地的封建领主。人类历史上第一次出现强盗无法夺走平民血汗钱的情况。
</p>

<p>
Making wealth is not the only way to get rich. For most of human history it has not even been the most common. Until a few centuries ago, the only ways to acquire these rapidly were by inheritance, marriage, conquest, or confiscation. Two things changed. The first was the rule of law. For most of the world’s history, if you did somehow accumulate a fortune, the ruler or his henchmen would find a way to steal it. But in medieval Europe something new happened. A new class of merchants and manufacturers began to collect in towns. Together they were able to withstand the local feudal lord. So for the first time in our history, the bullies stopped stealing the nerds’ lunch money.
</p>
</blockquote>

<blockquote>
<p>
创造财富的人能够心安理得地享用自己的财富，这确实是工业革命的一个必要条件。一个反面证据就是，试图违背这个条件的国家经济都出现了倒退。没有财富的激励，技术革新就会逐渐停顿。
</p>

<p>
&#x2026; the Industrial Revolution &#x2026;  a necessary, if not sufficient, condition was that people who made fortunes be able to enjoy them in peace. One piece of evidence is what happened to countries that tried to return to the old model. Take away the incentive of wealth, and technical innovation grinds to a halt.
</p>
</blockquote>

<blockquote>
<p>
资产阶级在历史上首先出现在意大利北部和荷兰，这可能不是偶然，因为那里没有强大的中央政府。选两个地区是那时最富裕的地方，后来变成了文艺复兴向外扩散的两大中心。
</p>

<p>
It is probably no accident that the middle class first appeared in northern Italy and the low countries, where there were no strong central governments. These two regions were the richest of their time and became the twin centers from which Renaissance civilization radiated.
</p>
</blockquote>

<blockquote>
<p>
为什么欧洲在历史上变得如此强大？答案（或者至少是近因）可能就是欧洲人接受了一个威力巨大的新观点：允许赚到大钱的人保住自己的财富。
</p>

<p>
Why Europe grew so powerful? The answer (or at least the proximate cause) may be that the Europeans rode on the crest of a powerful new idea: allowing those who made a lot of money to keep it.
</p>
</blockquote>

<blockquote>
<p>
冷战、第二次世界大战、近代的大多数战争都说明了这个道理。要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。
</p>

<p>
In that respect the Cold War teaches the same lesson as World War II and, for that matter, most wars in recent history. Don’t let a ruling class of warriors and politicians squash the entrepreneurs. The same recipe that makes individuals rich makes countries powerful. Let the nerds keep their lunch money, and you rule the world.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 第七章</h2>
<div class="outline-text-2" id="text-9">
<p>
关注贫富分化（Mind the Gap）
</p>

<blockquote>
<p>
有三个原因使得我们对赚钱另眼相看。第一，我们从小被误导的对财富的看法，第二，历史上积累财富的方式大多名声不好t第三，担心收入差距拉大将对社会产生不利影响。就我所知，第一点是错的，第二点已经过时了，第三点通不过现实的检验。
</p>

<p>
There are three reasons we treat making money as different: the misleading model of wealth we learn as children; the disreputable way in which, till recently, most fortunes were accumulated; and the worry that great variations in income are somehow bad for society. As far as I can tell, the first is mistaken, the second outdated, and the third empirically false.
</p>
</blockquote>

<blockquote>
<p>
已经很少有人直接创造财富供自己使用了。我们大多数人都在为其他人创造财富，然后用创造出来的财富交换金钱，再用金钱交换我们需要的另一种财富。
</p>

<p>
Few of us create wealth directly for ourselves. Mostly we create wealth for other people in exchange for money, which we then trade for the forms of wealth we want.
</p>
</blockquote>

<blockquote>
<p>
为什么财富的分配问题引起这么多争论？部分原因是反对声最大的人当中，很多人都少有创造财富的经验：大学生、继承人、教授，政客、新闻记者。
</p>

<p>
Part of the reason this subject is so contentious is that some of those most vocal on the subject of wealth—university students, heirs, professors, politicians, and journalists—have the least experience creating it.
</p>
</blockquote>

<blockquote>
<p>
抢银行、索贿、垄断市场也能搞到钱，并且是某些富豪最大的财富来源，但是这些手段不能代表财富的全部，更不是贫富分化的主要原因。每个人的技能不同，导致收入不同，这才是贫富分化的主要原因。
</p>

<p>
&#x2026; rob banks, or solicit bribes, or establish a monopoly. Such tricks account for some variation in wealth, and indeed for some of the biggest individual fortunes, but they are not the root cause of variation in income. The root cause of variation in income is the same as the root cause of variation in every other human skill.
</p>
</blockquote>

<blockquote>
<p>
想象一个人的产出是另一个人的 100 倍是一件毫无困难的事情。一个篮球队会同意用一个运动员交换 100 个普通人吗？如果苹果公司不是由乔布斯掌管，而是由一个 100 人组成的委员会掌管，那么这家公司的下一代产品会是什么样？
</p>

<p>
I have no trouble imagining that one person could be 100 times as productive as another. Would a basketball team trade one of their players for 100 random people? What would Apple’s next product look like if you replaced Steve Jobs with a committee of 100 random people?
</p>
</blockquote>

<blockquote>
<p>
一个人的工作具有多少价值不是由政府决定的，而是由市场决定的。
</p>

<p>
How much someone’s work is worth is not a policy question. It’s something the market already determines.
</p>
</blockquote>

<blockquote>
<p>
人们确实会需求不正确的东西。这有什么好奇怪的呢？你不觉得声称某种工作报酬过低的说法更奇怪吗？如果你觉得由于人们的需求不正确，导致某些工作的报酬过低而且不公平，那么这个世界一定会让你感到非常遗憾，人们就是喜欢看电视真人秀，而不是莎士比亚作品，人们就是喜欢吃玉米热狗，而不是水煮蔬菜。
</p>

<p>
People want the wrong things. It seems odd to be surprised by that. And it seems even odder to say that it’s unjust that certain kinds of work are underpaid. Then you’re saying that it’s unjust that people want the wrong things. It’s lamentable that people prefer reality TV and corndogs to Shakespeare and steamed vegetables.
</p>
</blockquote>

<blockquote>
<p>
一旦通过创造财富而使致富成为可能，社会从整体上就会快速地变得更富有。人们所需要的一切东西几乎都是由中产阶级生产出来的。工业革命后，其他两个阶级实际上消失了，他们的名称被用来指中产阶级的两端。
</p>

<p>
Once it became possible to get rich by creating wealth, society as a whole started to get richer very rapidly. Nearly everything we have was created by the middle class. Indeed, the other two classes have effectively disappeared in industrial societies, and their names been given to either end of the middle class.
</p>
</blockquote>

<blockquote>
<p>
创造财富真正取代掠夺和贪污成为致富的最佳方式，并不是发生在中世纪，而是发生在工业革命时代。至少在英国，当更快的致富方式出现后，贪污才逐渐不流行了。技术的发展使得通过创造而积累财富的速度第一次有可能超过通过偷窃而积累财富的速度。19 世纪典型的富人不是宫廷朝臣，而是实业家。
</p>

<p>
But it was not till the Industrial Revolution that wealth creation definitively replaced corruption as the best way to get rich. In England, at least, corruption only became unfashionable when there started to be other, faster ways to get rich. Technology had made it possible to create wealth faster than you could steal it. The prototypical rich man of the nineteenth century was not a courtier but an industrialist.
</p>
</blockquote>

<blockquote>
<p>
技术对生产效率的提高不是线性的，而可能是多项式形态（polynomial）的。所以，随着时间推移，我们应该会看到个人生产效率总是保持增长。
</p>

<p>
The rate at which technology increases our productive capacity is probably polynomial, rather than linear. So we should expect to see ever-increasing variation in individual productivity as time goes on.
</p>
</blockquote>

<blockquote>
<p>
技术应该会引起收入差距的扩大，但是似乎能缩小其他差距。一百年前，富人过着与普通人截然不同的生活。现在，由于技术的发展，富人的生活与普通人的差距缩小了。无论在物质上，还是在社会地位上，技术好像都缩小了富人与穷人之间的差距，而不是让这种差距扩大了。
</p>

<p>
Technology should increase the gap in income, but it seems to decrease other gaps. A hundred years ago, the rich led a different kind of life from ordinary people. Now, thanks to technology, the rich live more like the average person. Materially and socially, technology seems to be decreasing the gap between the rich and the poor, not increasing it.
</p>
</blockquote>

<blockquote>
<p>
技术无法使其变得更便宜的唯一东西，就是品牌。富人与穷人之间生活差异的鸿沟正在缩小，品牌是这种差距的遗留物。但是，品牌只是商品的标签，即使买不起名牌，至少你还可以买普通牌子，这总比根本无法消费这一种商品要好得多。1900 年，只要你有一辆马车，你就是富人，根本没人问你马车的牌子。今天，即使最穷的美国人也有自己的汽车，那么厂商只好通过广告训练我们识别品牌，以便我们能够识别哪些汽车特别昂贵。
</p>

<p>
The only thing technology can’t cheapen is brand. Brand is the residue left as the substantive differences between rich and poor evaporate. But what label you have on your stuff is a much smaller matter than having it versus not having it. In 1900, if you kept a carriage, no one asked what year or brand it was. If you had one, you were rich. Now even the poorest Americans drive cars, and it is only because we’re so well trained by advertising that we can even recognize the especially expensive ones.
</p>
</blockquote>

<blockquote>
<p>
一块普通的石英表，每天的误差大约是 0.5 秒。走时最准的百达望丽牌机械表，每天的误差是 -1.5 秒到 +2 秒，零售价是22万美元，
</p>

<p>
A Timex will gain or lose about .5 seconds per day. The most accurate mechanical watch, the Patek Philippe 10 Day Tourbillon, is rated at -1.5 to +2 seconds. Its retail price is about $220,000.
</p>
</blockquote>

<blockquote>
<p>
在农奴和贵族组成的社会，收入差距的加大肯定是社会问题加剧的信号，收入更多地从农奴流向了贵族。但是，抢夺他人的财富已经不再是收入的唯一来源了。波音 747 飞机驾驶员的收入大概是商场收银员的 40 倍，但是前者不是贵族，后者也不是奴隶，这种收入差距只是因为前者的技能比后者的要值钱得多。
</p>

<p>
In a society of serfs and warlords, certainly, variation in income is a sign of an underlying problem. But serfdom is not the only cause of variation in income. A 747 pilot doesn’t make 40 times as much as a checkout clerk because he is a warlord who somehow holds her in thrall. His skills are simply much more valuable.
</p>
</blockquote>

<blockquote>
<p>
现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了，（b）那些创造大部分财富的人停止工作了，（c）创造财富的人没有获得报酬。
</p>

<p>
In a modern society, increasing variation in income is a sign of health. Technology seems to increase the variation in productivity at faster than linear rates. If we don’t see corresponding variation in income, there are three possible explanations: (a) that technical innovation has stopped, (b) that the people who would create the most wealth aren’t doing it, or (c) that they aren’t getting paid for it.
</p>
</blockquote>

<blockquote>
<p>
如果得不到报酬，人们是否愿意创造财富？唯一的可能就是，工作必须能提供乐趣。会有人愿意免费写一个操作系统，但是他们不愿意免费为你安装、提供电话支持、进行客户培训等。即使是最先进的高科技公司，也有至少90%的工作没有乐趣、令人生厌。
</p>

<p>
Will people create wealth if they can’t get paid for it? Only if it’s fun. People will write operating systems for free. But they won’t install them, or take support calls, or train customers to use them. And at least 90% of the work that even the highest tech companies do is of this second, unedifying kind.
</p>
</blockquote>

<blockquote>
<p>
只要你压制收入差距的扩大，不管是用偷窃私人财产的做法（封建社会），还是用高额税收的做法（某些现代政府），最终结果看来都是一样的，那就是社会作为一个整体变得更贫穷了。
</p>

<p>
If you suppress variations in income, whether by stealing private fortunes, as feudal rulers used to do, or by taxing them away, as some modern governments have done, the result always seems to be the same. Society as a whole ends up poorer.
</p>
</blockquote>

<blockquote>
<p>
一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程做出的事情。
</p>

<p>
You need rich people in your society not so much because in spending their money they create jobs, but because of what they have to do to get rich.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 第八章</h2>
<div class="outline-text-2" id="text-10">
<p>
防止垃圾邮件的一种方法（A Plan for Spam）
</p>

<blockquote>
<p>
只要对单个词语进行贝叶斯判断，就能很好地过滤大部分垃圾邮件。我对贝叶斯方法寄予厚望，因为它的过滤能力可以随着垃圾邮件一起进化。
</p>

<p>
You can filter present-day spam acceptably well using nothing more than a Bayesian combination of the spam probabilities of individual words. I’m more hopeful about Bayesian filters, because they evolve with the spam.
</p>
</blockquote>

<blockquote>
<p>
对于大多数用户来说，错过一封正常的邮件后果要比收到垃圾邮件严重得多。如果你的过滤器效果越好，就越不能出现误判，一旦误判，后果就会变得很严重，因为过滤器工作得非常良好，所以用户相信它，就不太可能去检查被它过滤掉的邮件。
</p>

<p>
For most users, missing legitimate email is an order of magnitude worse than receiving spam. The better your spam filters get, the more dangerous false positives become, because when the filters are really good, users will be more likely to ignore everything they catch.
</p>
</blockquote>

<blockquote>
<p>
理想情况下，每个收信人应该都有自己单独的概率分布表。以我为例，我收到的许多邮件中都含有 Lisp 这个词，而迄今还没有垃圾邮件包含这个词。所以，一个这样的词实际上就像许可证一样，保证了这封信是发送给我的正常邮件。
</p>

<p>
Ideally, of course, the probabilities should be calculated individually for each user. I get a lot of email containing the word Lisp, and (so far) no spam that does. So a word like that is effectively a kind of password for sending mail to me.
</p>
</blockquote>

<blockquote>
<p>
刚开始的时候可以有一个所有人共享的基本概率分布表，但是到了最后，每个用户应该都分别有自己的概率分布表，这是根据他收到的邮件对每一个词进行统计后得出的。这样做可以使得垃圾邮件的发送者无法针对过滤器做出调整。
</p>

<p>
You could start users with a seed filter, but ultimately each user should have his own per-word probabilities based on the actual mail he receives. This makes it hard for spammers to tune mails to get through the filters.
</p>
</blockquote>

<blockquote>
<p>
如今的大多数垃圾邮件过滤器就像杀虫剂一样，唯一作用就是创造出杀不死的新品种害虫。
</p>

<p>
Most antispam techniques so far have been like pesticides that do nothing more than create a new, resistant strain of bugs.
</p>
</blockquote>

<blockquote>
<p>
未来的垃圾邮件可能就是下面这个样子：<br  />
嗨，你好。请查看链接 <a href="http://www.27meg.com/foo">http://www.27meg.com/foo</a><br  />
这差不多就是统计学过滤器能够允许通过的销售类邮件的样子。
</p>

<p>
the spam of the future will probably look something like this:<br  />
Hey there. Check out the following: <a href="http://www.27meg.com/foo">http://www.27meg.com/foo</a><br  />
because that is about as much sales pitch as content-based filtering will leave the spammer room to make.
</p>
</blockquote>

<blockquote>
<p>
虽然垃圾邮件的回应率低到不能再低了（不超过百万分之 15，相比之下，传统的邮寄商品目录的回应率是百万分之 3000），但是发送垃圾邮件的成本实际上为零，所以它还是有效的。
</p>

<p>
&#x2026; because although the response rate is abominably low (at best 15 per million, vs. 3000 per million for a catalog mailing), the cost, to them, is practically nothing.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 第九章</h2>
<div class="outline-text-2" id="text-11">
<p>
设计者的品位（Taste for Makers）
</p>

<blockquote>
<p>
喜欢一件东西，却不知道为什么自己喜欢它。人类的思想就是没有经过整理的无数杂念的混合。
</p>

<p>
When they like something, they have no idea why. Their thoughts are a tangle of unexamined impulses.
</p>
</blockquote>

<blockquote>
<p>
众多不同学科对「美」的认识有着惊人的相似度。优秀设计的原则是许多学科的共同原则，一再反复地出现。
</p>

<p>
It’s surprising how much different fields’ ideas of beauty have in common. The same principles of good design crop up again and again.
</p>
</blockquote>

<blockquote>
<p>
好设计是简单的设计。当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。
</p>

<p>
Good design is simple. When you’re forced to be simple, you’re forced to face the real problem. When you can’t deliver ornament, you have to deliver substance.
</p>
</blockquote>

<blockquote>
<p>
好设计是永不过时的设计。如果你希望自己的作品对未来的人们有吸引力，方法之一就是让你的作品对上几代人有吸引力。
</p>

<p>
Good design is timeless. If you want to make something that will appeal to future generations, one way to do it is to try to appeal to past generations.
</p>
</blockquote>

<blockquote>
<p>
好设计是启发性的设计。在建筑学和设计学中，这条原则意味着，一幢建筑或一个物品应该允许你按照自己的愿望来使用。
</p>

<p>
Good design is suggestive. In architecture and design, this principle means that a building or object should let you use it as you want.
</p>
</blockquote>

<blockquote>
<p>
幽默一定程度上反映了力量。幽默感是强壮的一种表现。
</p>

<p>
Humor is related to strength. To have a sense of humor is to be strong.
</p>
</blockquote>

<blockquote>
<p>
并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。
</p>

<p>
Not every kind of hard is good. There is good pain and bad pain. You want the kind of pain you get from going running, not the kind you get from stepping on a nail.
</p>
</blockquote>

<blockquote>
<p>
在大多数领域，看上去容易的事情，背后都需要大量的练习。练习的作用也许是训练你把刻意为之的事情变成一种自觉的行为。
</p>

<p>
In most fields the appearance of ease seems to come with practice. Perhaps what practice does is train your unconscious mind to handle tasks that used to require conscious thought.
</p>
</blockquote>

<blockquote>
<p>
对称有两种：重复性对称和递归性对称。递归性对称就是指产元素的重复，比如树叶上叶脉的纹路。
</p>

<p>
There are two kinds of symmetry, repetition and recursion. Recursion means repetition in subelements, like the pattern of veins in a leaf.
</p>
</blockquote>

<blockquote>
<p>
在软件中，能用递归解决的问题通常代表已经找到了最佳解法。
</p>

<p>
In software, a problem that can be solved by recursion is nearly always best solved that way.
</p>
</blockquote>

<blockquote>
<p>
好设计是一种再设计。很少有人一次就把事情做对。专家的做法是先完成一个早期原型，然后提出修改计划，最后把早期原型扔掉。
</p>

<p>
Good design is redesign. It’s rare to get things right the first time. Experts expect to throw away some early work. They plan for plans to change.
</p>
</blockquote>

<blockquote>
<p>
等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。你的品味就进入了第二阶段，开始自觉地进行原创。
</p>

<p>
The ambitious are not content to imitate. The second phase in the growth of taste is a conscious attempt at originality.
</p>
</blockquote>

<blockquote>
<p>
最伟大的大师最终会达到一种超脱自我的境界。他们一心想找到正确答案，如果别人已经回答出了一部分，那就没理由不拿来用。他们足够自信地使用他人的成果，完全不担心闪此丧失个人的特点。
</p>

<p>
The greatest masters go on to achieve a kind of selflessness. They just want to get the right answer, and if part of the right answer has already been discovered by someone else, that’s no reason not to use it. They’re confident enough to take from anyone without feeling that their own vision will be lost in the process.
</p>
</blockquote>

<blockquote>
<p>
推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。互相激励比天赋更重要。今天，人类生活的流动性高得多，但是伟大的项目依然不成比例地集中在少数几个热点上：德国包豪斯建筑学院、曼哈顿计划、《纽约人》杂志、洛克希德公司的臭鼬工作室，施乐公司的帕洛阿尔托研究中心。
</p>

<p>
Nothing is more powerful than a community oftalented people working on related problems. Genes count for little by comparison. Today we move around more, but great work still comes disproportionately from a few hotspots: the Bauhaus, the Manhattan Project, The New Yorker, Lockheed’s Skunk Works, Xerox Parc.
</p>
</blockquote>

<blockquote>
<p>
优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。
</p>

<p>
The recipe for great work is: very exacting taste, plus the ability to gratify it.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 第十章</h2>
<div class="outline-text-2" id="text-12">
<p>
编程语言解析（Programming Languages Explained）
</p>

<blockquote>
<p>
编程语言的一个重要特点：一个操作所需的代码越多，就越难避免 bug，也越难发现它们。
</p>

<p>
An important point about languages: the more you have to say to get something done, the harder it is to see bugs.
</p>
</blockquote>

<blockquote>
<p>
所谓「编译器」，本身就是一个程序，作用是将简便方式书写的程序转变为硬件可以理解的语言。
</p>

<p>
A compiler is a program that translates programs written in a convenient form into the simple-minded language that the hardware understands.
</p>
</blockquote>

<blockquote>
<p>
高级语言使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的。如果你的程序是用高级语言写的，你只需要重写编译器就可以了。
</p>

<p>
High-level languages make your programs more portable. Different computers all have slightly different machine languages. If you use a high-level language, all you have to rewrite is the compiler.
</p>
</blockquote>

<blockquote>
<p>
编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。
</p>

<p>
Compilers aren’t the only way to implement high-level languages. You could also use an interpreter, which examines your program one piece at a time and executes the corresponding machine language commands, instead of translating the whole thing into machine language and running that.
</p>
</blockquote>

<blockquote>
<p>
普通的消费者也许不需要看到他们使用的文字处理器的源码，但是在非常强调软件可靠性的情况下，出于强烈的工程需求的考虑，会要求开放源码。
</p>

<p>
The average end user may not need the source code of their word processor, but when you really need reliability, there are solid engineering reasons for insisting on open source.
</p>
</blockquote>

<blockquote>
<p>
现在很少有人使用汇编语言。程序员的时间要比计算机的时间昂贵得多。只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观水平控制硬件，使得游戏速度得到最大限度的终极提高。
</p>

<p>
Few use assembly language now. Computer time has become much cheaper, while programmer time is as expensive as ever. You might do it in a few critical parts of, say, a computer game, where you wanted to micromanage the hardware to squeeze out that last increment of speed.
</p>
</blockquote>

<blockquote>
<p>
「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」这当然是一派胡言，各种语言简直是天差地别。
</p>

<p>
It don’t matter which you use. What matters is whether you have the right stuff. This is nonsense, of course. There is a world of difference.
</p>
</blockquote>

<blockquote>
<p>
一些黑客只喜欢自己用的语言，反感其他所有的语言。另一些黑客则说所有的语言都一样。事实介于这两个极端之间。语言之间确实有差别，但是很难确定地说哪一种语言是最好的。
</p>

<p>
Some hackers prefer the language they’re used to, and dislike anything else. Others say that all languages are the same. The truth is somewhere between these two extremes. Languages do differ, but it’s hard to say for certain which are best.
</p>
</blockquote>

<blockquote>
<p>
C 语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用 C 语言写的，这并非偶然。
</p>

<p>
C is quite low-level, almost a portable assembly language. If you need code to be super fast, it’s better to stay close to the machine. Most operating systems are written in C, and it is not a coincidence.
</p>
</blockquote>

<blockquote>
<p>
最常见的几种入侵计算机的手法都是利用了 C 语言的某些特点。当你在 C 语言中为输入的内容分配出一片内存时，它会被分配在当前运行代码的返回地址旁边。所谓「返同地址」指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。也就是说，它实际上是计算机下一步要做的事情。假定有人打算入侵你的计算机，他们猜出你会为某种输入分配 256 字节的缓存，于是他们就提交多于 256 字节的内容，目的是覆盖旁边的「返回地址」。当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地址通常是缓存的首地址，缓存中是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。
</p>

<p>
The most common way of breaking into computers takes advantage of some idiosyncrasies of C. In C, when you set aside a chunk of memory (a buffer) for some input you’re expecting, it gets allocated next to the memory containing the return address of the currently running code. The return address is the location in memory of the code that’s going to be executed when the current code is done. It is, in effect, the next thing on the computer’s to-do list. So if someone wants to break into your computer, and they guess you’re using a 256-byte buffer to store some kind of input, then by sending just over 256 bytes they can overwrite the return address. When the current code is done, control will pass to whatever location in memory they’ve specified. And the location they’ll usually specify will be the beginning of the buffer, which they’ve just filled up with the machine language program of their choice. Bingo: their program is now running on your computer.
</p>
</blockquote>

<blockquote>
<p>
有意思的是，劫持飞机与「缓冲区溢出攻击」有类似之处。在一般飞机上，乘客区与驾驶舱是相通的，就好像 C 语言中数据区与代码区是相邻的一样。劫机者一旦进入驾驶舱，实际上就相当于把自己从数据提升为代码。
</p>

<p>
Curiously, airline hijackings are also buffer overflow attacks. In an ordinary airliner, passengers and cockpit are adjacent, just as data and code are adjacent in a C program. By overflowing into the cockpit, hijackers in effect promote themselves from data to code.
</p>
</blockquote>

<blockquote>
<p>
语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java 语言是前一个阵营的代表，Perl 语言则是后一个阵营的代表。
</p>

<p>
The biggest debate in language design is probably the one between those who think that a language should prevent programmers from doing stupid things, and those who think programmers should be allowed to do whatever they want. Java is in the former camp, and Perl in the latter.
</p>
</blockquote>

<blockquote>
<p>
静态类型语言的拥护者认为这样可以防止 bug，并且帮助编译器生成更快的代码（这两点理由都成立）。动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。
</p>

<p>
Advocates of static typing argue that it helps to prevent bugs and helps compilers to generate fast code (both true). Advocates of dynamic typing argue that static typing restricts what programs you can write (also true).
</p>
</blockquote>

<blockquote>
<p>
事实上有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程。允许你做某事的语言肯定不差于强迫你做某事的语言。
</p>

<p>
There are two senses of object-oriented: some languages are object-oriented in the sense that they let you program in that style, and others in the sense that they force you to. Surely a language that lets you do x is at least as good as one that forces you to.
</p>
</blockquote>

<blockquote>
<p>
……一些也许可以称为「头重脚轻」的语言：它们的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。这些库本身可能比核心的语言还要重要。
</p>

<p>
&#x2026; a kind of language you might call top-heavy: a language whose inner core is not very well designed, but which has enormously powerful libraries of code for solving specific problems. Libraries are probably more important than the core language.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> 第十一章</h2>
<div class="outline-text-2" id="text-13">
<p>
一百年后的编程语言（The Hundred-Year Language）
</p>

<blockquote>
<p>
编程语言就像生物物种一样，存在一个进化的脉络，许许多多分支最终都会成为进化的死胡同。Cobol语言曾经流行一时，但是现在看来没有任何后续语言继承它的思想。它就像尼安德特人一样，进化之路已经走到了尽头。
</p>

<p>
Like species, languages will form evolutionary trees, with dead-ends branching off all over. Cobol, for all its sometime popularity, does not seem to have any intellectual descendants. It is an evolutionary deadend—a Neanderthal language.
</p>
</blockquote>

<blockquote>
<p>
如果标准是相关书籍的出版量，或者是相信学会 Java 就能找到工作的大学生数量，那么 Java 确实已经成功了。当我说 Java 不会成功时，我的意思是它和 Cobol 一样，进化之路已经走到了尽头。
</p>

<p>
Java is already a successful language if you measure success by shelf space taken up by books on it, or by the number of undergrads who believe they have to learn it to get a job. When I say Java won’t turn out to be a successful language, I mean something more specific: that Java will turn out to be an evolutionary dead-end, like Cobol.
</p>
</blockquote>

<blockquote>
<p>
选择那些靠近主干的语占，这样对当前的编程最有利。
</p>

<p>
Staying close to the main branches is a useful heuristic for finding languages that will be good to program in now.
</p>
</blockquote>

<blockquote>
<p>
编程语言之所以可能出现聚合，一个原因是它的概率空间比较小，另一个原因是它的突变不是随机的。语言的设计者们总是有意识地借鉴其他语言的设计思想。
</p>

<p>
Convergence is more likely for languages partly because the space of possibilities is smaller, and partly because mutations are not random. Language designers deliberately incorporate ideas from other languages.
</p>
</blockquote>

<blockquote>
<p>
冗余的代码会导致更多冗余的代码。那些内核最小，最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。
</p>

<p>
Cruft breeds cruft. The main branches of the evolutionary tree pass through the languages that have the smallest, cleanest cores. The more of a language you can write in itself, the better.
</p>
</blockquote>

<blockquote>
<p>
编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问题。所以，编程语言的进化速度更像数学符号的进化速度，而不像真正的技术（比如交通或通信技术）的进化速度。
</p>

<p>
Languages evolve slowly because they’re not really technologies. Languages are notation. A program is a formal description of the problem you want a computer to solve for you. So the rate of evolution in programming languages is more like the rate of evolution in mathematical notation than, say, transportation or communications. Mathematical notation does evolve, but not with the giant leaps you see in technology.
</p>
</blockquote>

<blockquote>
<p>
无论一百年后的计算机是什么样子，我们基本上可以断定它们的运行速度一定会快得多。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。
</p>

<p>
Whatever computers are made of in a hundred years, it seems safe to predict they will be much faster. Among other things, there will be more room for what would now be considered slow languages, meaning languages that don’t yield very efficient code.
</p>
</blockquote>

<blockquote>
<p>
随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。
</p>

<p>
As technologies improve, each generation can do things that the previous generation would have considered wasteful.
</p>
</blockquote>

<blockquote>
<p>
很多数据结构存存的原因都与计算机的速度有关。从语义上看，字符串或多或少可以理解成列表的一个子集，其中的每一个元素都是字符。只是为了提高效率，所以字符串才会存在。但是，这种以加快运行速度为目的，却使得编程语言的语义大大复杂的行为，很不可取。编程语言设置字符串似乎就是一个过早优化的例子。正确做法应该是将语言的语义与语占的实现予以分离。在语义上不需要同时存在列表和字符串，单单列表就够了。而在实现上做好编译器优化，使它在必要时把字符串作为连续字节的形式处理。
</p>

<p>
Most data structures exist because of speed. Semantically, strings are more or less a subset of lists in which the elements are characters. Strings only exist for efficiency. But it’s lame to clutter up the semantics of a language with hacks to make programs run faster. Having strings in a language seems to be a case of premature optimization. The right way to solve that problem is to separate the meaning of a program from the implementation details. Instead of having both lists and strings, have just lists, with some way to give the compiler optimization advice that will allow it to lay out strings as contiguous bytes if necessary.
</p>
</blockquote>

<blockquote>
<p>
一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言，哪怕它的效率低下得惊人（至少按我们今天的眼光来看是如此）。效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快，这会变得越来越明显。
</p>

<p>
What programmers in a hundred years will be looking for, most of all, is a language where you can throw together an unbelievably inefficient version 1 of a program with the least possible effort. At least, that’s how we’d describe it in present-day terms. Inefficient software isn’t gross. What’s gross is a language that makes programmers do needless work. Wasting programmer time is the true inefficiency, not wasting machine time. This will become ever more clear as computers get faster.
</p>
</blockquote>

<blockquote>
<p>
另一种消耗硬件性能的方法就是，在应用软件与硬件之间设置很多的软件层。这也是我们已经看到的一种趋势，许多新兴的语言就被编译成字节码。根据经验判断，每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。
</p>

<p>
Another way to burn up cycles is to have many layers of software between the application and the hardware. This too is a trend we see happening already: many recent languages are compiled into byte code. As a rule of thumb, each layer of interpretation costs a factor of ten in speed. This extra cost buys you flexibility.
</p>
</blockquote>

<blockquote>
<p>
自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯――可重用性的最佳路线。
</p>

<p>
Bottom-up programming means writing a program as a series of layers, each of which serves as a language for the one above. This approach tends to yield smaller, more flexible programs. It’s also the best route to that holy grail, reusability.
</p>
</blockquote>

<blockquote>
<p>
某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它使用了面向对象编程，而是因为它的开发方法是自下而上的。以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为它们采用面向对象或者其他编程方法。
</p>

<p>
Although some object-oriented software is reusable, what makes it reusable is its bottom-upness, not its object-orientedness. Consider libraries: they’re reusable because they’re language, whether they’re written in an object-oriented style or not.
</p>
</blockquote>

<blockquote>
<p>
除了某些特定的领域，面向对象编程其实没有为优秀程序员带来很多好处，但是它对大公司有不可抗拒的吸引力。面向对象编程使得你有办法对面条式代码进行可持续性开发。通过不断地打补丁，它让你将软件一步步做大。大公司总是倾向于采用这样的方式开发软件。
</p>

<p>
Though I don’t think object-oriented programming has much to offer good programmers, except in certain specialized domains, it is irresistible to large organizations. Object-oriented programming offers a sustainable way to write spaghetti code. It lets you accrete programs as a series of patches. Large organizations always tend to develop software this way.
</p>
</blockquote>

<blockquote>
<p>
有些语言可以达到机器的最高效率，另一些语言的效率则慢到刚刚可以运行而已，两者之间存在巨大的差距。一百年后，这段差距之间的各个点上都会有对应的编程语言存在。
</p>

<p>
Despite the huge gap they’ll have between acceptable and maximal efficiency, programmers in a hundred years will have languages that can span most of it.
</p>
</blockquote>

<blockquote>
<p>
性能分析器将变得越来越重要。目前，性能分析并没有受到重视。许多人好像仍然相信，程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。代码效率与机器性能的差距正在不断加大，我们将会越来越清楚地看到，应用软件运行速度提升的关键在于有一个好的性能分析器帮助指导程序开发。
</p>

<p>
Profilers will become increasingly important. Little attention is paid to profiling now. Many people still seem to believe that the way to get fast applications is to write compilers that generate fast code. As the gap between acceptable and maximal performance widens, it will become increasingly clear that the way to get fast applications is to have a good guide from one to the other.
</p>
</blockquote>

<blockquote>
<p>
新语言更多地以开源项目的形式出现，而不是以研究性项目的形式出现。这是语言的一种发展趋势。另一种发展趋势是，新语言的设计者更多的是本身就需要使用它们的应用软件作者，而不是编译器作者。
</p>

<p>
The trend is not merely toward languages being developed as open source projects rather than “research”, but toward languages being designed by the application programmers who need to use them, rather than by compiler writers.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> 第十二章</h2>
<div class="outline-text-2" id="text-14">
<p>
拒绝平庸（Beating the Averages）
</p>

<blockquote>
<p>
如果你想当一个黑客，从 Python 和 Java 入手，因为它们比较容易学。想当高级一点的黑客，还应该学习 C 和 Perl。前者用来对付 Unix 系统，后者用来系统管理和开发 CGI 脚本。最后，真正非常严肃地把黑客作为人生目标的人，应该考虑学习 Lisp。
</p>

<p>
&#x2026; tells would-be hackers what languages they should learn. Starting with Python and Java, because they are easy to learn. The serious hacker will also want to learn C, in order to hack Unix, and Perl for system administration and CGI scripts. Finally, the truly serious hacker should consider learning Lisp.
</p>
</blockquote>

<blockquote>
<p>
大公司每年平均成长大约l0%。如果你掌管一家大公司，只要每件事都做到大公司的平均水准，你就能得到大公司的平均结果。小公司的平均结果就意味着关门倒闭。创业公司的生存率远低于 50%。所以，如果你掌管创业公司，最好做一些独特的事情，否则就会有麻烦。
</p>

<p>
The average big company grows at about ten percent a year. So if you’re running a big company and you do everything the way the average big company does it, you can expect to do as well as the average big company. The problem for a startup is, average performance means you’ll go out of business. The survival rate for startups is way less than fifty percent. So if you’re running a startup, you had better be doing something odd. If not, you’re in trouble.
</p>
</blockquote>

<blockquote>
<p>
如果开发只在自己服务器上运行的软件，这意味着你想用什么语言就能用什么语言。如果开发桌面软件，就完全不一样了，大多数情况下你只能使用操作系统所用的开发语言。
</p>

<p>
When you’re writing software that only has to run on your own servers, you can use any language you want. When you’re writing desktop software, there’s a strong bias toward writing applications in the same language as the operating system.
</p>
</blockquote>

<blockquote>
<p>
在竞争中，你的对手无法理解你的技术优势，这可是再宝贵不过了。商场如战场，对手摸不透你，你的胜算就增加了。
</p>

<p>
In business, there is nothing more valuable than a technical advantage your competitors don’t understand. In business, as in war, surprise is worth as much as force.
</p>
</blockquote>

<blockquote>
<p>
编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。人类天性变化的速度大大慢于计算机硬件变化的速度，所以编程语言的发展通常比 CPU 的发展落后一二十年。技术的变化速度通常是很快的。但是，编程语言不一样，与其说它是技术，还不如说是程序员的思考模式。
</p>

<p>
It’s the nature of programming languages to make most people satisfied with whatever they currently use. Computer hardware changes so much faster than personal habits that programming practice is usually ten to twenty years behind the processor. Ordinarily technology changes fast. But programming languages are different: programming languages are not just technology, but what programmers think in.
</p>
</blockquote>

<blockquote>
<p>
有些公司的职位描述使用了大量的 IT 词汇，这样的内容越多，这家公司就越不构成威胁。最不用担心的竞争对手就是那些要求应聘者具有 Oracle 数据库经验的公司，你永远不必担心他们。如果是招聘 C++ 或 Java 程序员的公司，对你也不会构成威胁。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司，就会真的感到如临大敌。
</p>

<p>
The more of an IT flavor the job descriptions had, the less dangerous the company was. The safest kind were the ones that wanted Oracle experience. You never had to worry about those. You were also safe if they said they wanted C++ or Java developers. If they wanted Perl or Python programmers, that would be a bit frightening—that’s starting to sound like a company where the technical side, at least, is run by real hackers. If I had ever seen a job posting looking for Lisp hackers, I would have been really worried.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> 第十三章</h2>
<div class="outline-text-2" id="text-15">
<p>
书呆子的复仇（Revenge of the Nerds）
</p>

<blockquote>
<p>
那些经理奇迹般地同时具备了两种很常见但很难结合在一起的特点：（a）对技术一无所知，（b）对技术有强烈的个人观点。
</p>

<p>
The pointy-haired boss miraculously combines two qualities that are common by themselves, but rarely seen together: (a) he knows nothing whatsoever about technology, and (b) he has very strong opinions about it.
</p>
</blockquote>

<blockquote>
<p>
他的想法无非就是，Java 是业界的标准，因为媒体对此有铺天盖地的报道。既然它是标准，那么使用它就不会错。另外，这也意味着人才市场上肯定有无数 Java 程序员，即使现在为我打工的这批人都辞职了，我也能够轻易地找到替代者。
</p>

<p>
What he’s thinking is something like this. Java is a standard. Because I read about it in the press all the time. Since it is a standard, I won’t get in trouble for using it. And that also means there will always be lots of Java programmers, so if those working for me now quit, I can easily replace them.
</p>
</blockquote>

<blockquote>
<p>
一般来说，如果你动手创造一种新语言，那是因为你觉得它在某些方面会优于现有的语言。Java 语言之父詹姆斯・戈斯林在第一份《Java 白皮书》中说得很清楚，之所以要设计 Java，就是想解决 C++ 的一些弱点。
</p>

<p>
Presumably, if you create a new language, it’s because you think it’s better in some way than what people already had. And in fact, Gosling makes it clear in the first Java white paper that Java was designed to fix some problems with C++.
</p>
</blockquote>

<blockquote>
<p>
如果语言各有不同，你的经理就会突然发现，有两个互相关联的方程，他必须找到一个能够同时满足两个方程的最佳解，而最要命的却是他对此根本一无所知。第一个方程是找到（相对于要解决的问题）能够适用 20 年左右的最佳语言，第二个方程是（为这种语言）找到合适的程序员、函数库的机会有多大。
</p>

<p>
If languages vary, he suddenly has to solve two simultaneous equations, trying to find an optimal balance between two things he knows nothing about: the relative suitability of the twenty or so leading languages for the problem he needs to solve, and the odds of finding programmers, libraries, etc. for each.
</p>
</blockquote>

<blockquote>
<p>
由此也就得出了 20 世纪 50 年代的编程语言（Lisp）到现在还没有过时的原因。简单说，因为这种语言本质上不是一种技术，而是数学。数学是不会过时的。
</p>

<p>
So the short explanation of why this 1950s language is not obsolete is that it was not technology but math, and math doesn’t get stale.
</p>
</blockquote>

<blockquote>
<p>
许多项目是无所谓选择哪一种编程语言，反正不同的语言都能完成工作。一般来说，条件越苛刻的项目，强大的编程语言就越能发挥作用。
</p>

<p>
There are, of course, projects where the choice of programming language doesn’t matter much. As a rule, the more demanding the application, the more leverage you get from using a powerful language.
</p>
</blockquote>

<blockquote>
<p>
使用一种不常见的语言会出现的问题我想到了三个：你的程序可能无法很好地与使用其他语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。
</p>

<p>
I can think of three problems that could arise from using less common languages. Your programs might not work well with programs written in other languages. You might have fewer libraries at your disposal. And you might have trouble hiring programmers.
</p>
</blockquote>

<blockquote>
<p>
把软件运行在服务器端就可以没有顾忌地使用最先进的技术。这也能解释为什么像 Perl 和 Python 这样的新语言会流行起来，它们之所以流行不是因为人们使用它们开发 Windows 应用程序，而是因为人们在服务器上使用它们。随着软件从桌面端向服务器端转移，逼迫你使用某一种语言的限制将越来越少。
</p>

<p>
In server-based applications you can get away with using the most advanced technologies. This is why we even hear about new languages like Perl and Python. We’re not hearing about these languages because people are using them to write Windows apps, but because people are using them on servers. And as software shifts off the desktop and onto servers, there will be less and less pressure to use middle-of-the-road technologies.
</p>
</blockquote>

<blockquote>
<p>
事实上，选择更强大的编程语言会减少所需要的开发人员数量。因为：（a）如果你使用的语言很强大，可能会减少一些编程的工作量，也就不需要那么多黑客了，（b）使用更高级语言的黑客可能比别的程序员更聪明。
</p>

<p>
In fact, choosing a more powerful language probably decreases the size of the team you need, because (a) if you use a more powerful language, you probably won’t need as many hackers, and (b) hackers who work in more advanced languages are likely to be smarter.
</p>
</blockquote>

<blockquote>
<p>
如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品。让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。如果没有用户，谁会关心你选择的「正统」技术是多么令人放心。
</p>

<p>
If you start a startup, don’t design your product to please VCs or potential acquirers. Design your product to please the users. If you win the users, everything else will follow. And if you don’t, no one will care how comfortingly orthodox your technology choices were.
</p>
</blockquote>

<blockquote>
<p>
强大的编程语言如何让你写出更短的程序？一个技巧就是（在语言允许的前提下）使用「自下而上」的编程方法。你不是用基础语言开发应用程序，而是在基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。这样写出来的代码会比直接用基础语言开发出来的短得多。
</p>

<p>
How does a more powerful language enable you to write shorter programs? One technique you can use, if the language will let you, is something called bottom-up programming. Instead of simply writing your application in the base language, you build on top of the base language a language for writing programs like yours, then write your program in it. The combined code can be much shorter than if you had written your whole program in the base language.
</p>
</blockquote>

<blockquote>
<p>
你的经理其实不关心公司是否真的能获得成功，他真正关心的是不承担决策失败的责任。所以对他个人来说，最安全的做法就是跟随大多数人的选择。在大型组织内部，有一个专门的术语描述这种跟随大多数人的选择的做法，叫做「业界最佳实践」。这个词出现的原因其实就是为了让你的经理可以推卸责任。
</p>

<p>
The pointy-haired boss doesn’t mind if his company gets their ass kicked, so long as no one can prove it’s his fault. The safest plan for him personally is to stick close to the center of the herd. Within large organizations, the phrase used to describe this approach is “industry best practice.” Its purpose is to shield the pointy-haired boss from responsibility.
</p>
</blockquote>

<blockquote>
<p>
所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言写出任何一个程序。
</p>

<p>
The fact that all these languages are Turingequivalent means that, strictly speaking, you can write any program in any of them.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> 第十四章</h2>
<div class="outline-text-2" id="text-16">
<p>
梦寐以求的编程语言（The Dream Language）
</p>

<blockquote>
<p>
优秀的语言不一定会被市场接受，很可能无人使用，因为语言的流行不取决于它本身。大多数人选择某一种编程语言，不是因为这种语言有什么独特的特点，而是因为听说其他人使用这种语言。
</p>

<p>
Programming languages don’t become popular or unpopular based on their merits. Most people don’t choose programming languages simply based on their merits. Most programmers are told what language to use by someone else.
</p>
</blockquote>

<blockquote>
<p>
大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有优秀软件。
</p>

<p>
the majority of programmers can’t tell a good language from a bad one. But that’s no different with any other tool. It doesn’t mean that it’s a waste of time to try designing a good language. Expert hackers can tell a good language when they see one, and they’ll use it. Expert hackers are a tiny minority, admittedly, but that tiny minority write all the good software.
</p>
</blockquote>

<blockquote>
<p>
从长期来看，专家级黑客的看法是最重要的因素。只要有了达到「临界数量」的最初用户和足够长的时间，一种语言可能就会达到应有的流行程度。而流行本身又会使得这种优秀的语言更加优秀，进一步拉大它与平庸语言之间的好坏差异，因为使用者的反馈总是会导致语言的改进。
</p>

<p>
The opinion of expert hackers is the most powerful force over the long term. Given an initial critical mass and enough time, a programming language probably becomes about as popular as it deserves to be. And popularity further separates good languages from bad ones, because feedback from real live users always leads to improvements.
</p>
</blockquote>

<blockquote>
<p>
有一个外部因素会影响到语言的流行。一种语言必须是某一个流行的计算机系统的脚本语言，才会变得流行。Fortran 和 Cobol 是早期 IBM 大型机的脚本语言。C 是 Unix 的脚本语言，后来的 Perl 和 Python 也是如此。Tcl 是 Tk 的脚本语言，Visual Basic 是 Windows 的脚本语言，（某种形式的）Lisp 是 Emacs 的脚本语言，PHP 是网络服务器的脚本语言，Java 和 JavaScript 是浏览器的脚本语言。
</p>

<p>
One external factor that does affect the popularity of a programming language. To become popular, a programming language has to be the scripting language of a popular system. Fortran and Cobol were the scripting languages of early IBM mainframes. C was the scripting language of Unix, and so, later, were Perl and Python. Tcl is the scripting language of Tk, Visual Basic of Windows, (a form of) Lisp of Emacs, PHP of web servers, and Java and Javascript of web browsers.
</p>
</blockquote>

<blockquote>
<p>
黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。
</p>

<p>
One thing hackers like is succinctness. Hackers are lazy, in the same way that mathematicians and modernist architects are lazy: they hate anything extraneous.
</p>
</blockquote>

<blockquote>
<p>
语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。
</p>

<p>
Language designers would do better to consider their target user to be a genius who will need to do things they never anticipated, rather than a bumbler who needs to be protected from himself.
</p>
</blockquote>

<blockquote>
<p>
对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。
</p>

<p>
When you make any tool, people use it in ways you didn’t intend.
</p>
</blockquote>

<blockquote>
<p>
一种真正优秀的编程语言应该既整洁又混乱。「整洁」的意思是设计得很清楚，内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。「混乱」的意思是它允许黑客以自己的方式使用。
</p>

<p>
A really good language should be both clean and dirty: cleanly designed, with a small core of well understood and highly orthogonal operators, but dirty in the sense that it lets hackers have their way with it.
</p>
</blockquote>

<blockquote>
<p>
所谓一次性程序，就是指为了完成某些很简单的临时性任务而在很短时间内写出来的程序。许多一次性程序后来也都变成了正式的程序，具备了正式的功能和外部用户。我有一种预感，最优秀的那些大型程序就是这样发展起来的，而不是像胡佛水坝那样从一开始就作为大型工程来设计。一下子从无到有做出一个大项目是很恐怖的一件事。
</p>

<p>
A throwaway program is a program you write quickly for some limited task. Many throwaway programs evolve into real programs, with real features and real users. I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam. It’s terrifying to build something big from scratch.
</p>
</blockquote>

<blockquote>
<p>
我认为，未来 50 年中，编程语言的进步很大一部分与函数库有关。未来的函数库将像语言内核一样精心设计。优秀函数库的重要性将超过语言本身。某种语言到底是静态类型还是动态类型、是面向对象还是函数式编程，这些都不如函数库重要。
</p>

<p>
I think a lot of the advances that happen in programming languages in the next fifty years will have to do with library functions. I think future programming languages will have libraries that are as carefully designed as the core language. Programming language design will not be about whether to make your language statically or dynamically typed, or object-oriented, or functional, or what- ever, so much as about how to design great libraries.
</p>
</blockquote>

<blockquote>
<p>
许多年以来，大多数面向最终用户的程序都不太关心效率。软件开发者总是假设用户桌面电脑的运算能力会不断增长，所以不用刻意提高软件的效率。帕金森定律被证明与摩尔定律一样颠扑不破。软件不断膨胀，消耗光所有可以得到的资源。这一切将随着互联网软件的出现发生改变，因为硬件和软件现在捆绑在一起供应。对于那些提供互联网软件的公司来说，将每台服务器支持的用户数量最大化会对降低成本产生巨大影响。
</p>

<p>
For years, efficiency hasn’t mattered much in most end-user applications. Developers have been able to assume that users would have increasingly fast processors sitting on their desks. And Parkinson’s Law has proven as powerful as Moore’s. Software has bloated to consume the resources available. That will change with server-based applications, because hardware and software will be supplied together. For companies that offer server-based applications, it will make a big difference to the bottom line how many users they can support per server.
</p>
</blockquote>

<blockquote>
<p>
帕金森定律（Parkinson's Law）的一种原始表达形式是：工作总是到最后一刻才会完成’，后来引用到计算机领域就变成了「数据总是会填满所有空间」，更一般性的总结则是「对一种资源的需求总是会消耗光速种资源的序有供应」。
</p>
</blockquote>

<blockquote>
<p>
大多数人接触新事物时都学会了使用类似的过滤机制。甚至有时要听到别人提起十遍以上他们才会留意。这样做完全是合理的，因为大多数的热门新商品事后被证明都是浪费时间的噱头，没多久就消失得无影无踪。
</p>

<p>
Most people have learned to do a similar sort of filtering on new things they hear about. They don’t even start paying attention until they’ve heard about something ten times. They’re perfectly justified: the majority of hot new whatevers do turn out to be a waste of time, and eventually go away.
</p>
</blockquote>

<blockquote>
<p>
你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。
</p>

<p>
All you have to do is keep telling your story, and eventually people will start to hear. It’s not when people notice you’re there that they pay attention; it’s when they notice you’re still there.
</p>
</blockquote>

<blockquote>
<p>
「最好的文字来自不停的修改」。所有优秀作家都知道这一点，它对软件开发也适用。设计一样东西，最重要的一点就是要经常「再设计」，编程尤其如此，再多的修改都不过分。
</p>

<p>
“The best writing is rewriting.” Every good writer knows this, and it’s true for software too. The most important part of design is redesign. Programming languages, especially, don’t get redesigned enough.
</p>
</blockquote>

<blockquote>
<p>
为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你义要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。
</p>

<p>
To write good software you must simultaneously keep two opposing ideas in your head. You need the young hacker’s naive faith in his abilities, and at the same time the veteran’s skepticism.
</p>
</blockquote>

<blockquote>
<p>
用户是一把双刃剑。他们推动语言的发展，但也使得你不敢对语言进行大规模改造。所以，一开始的时候要精心选择用户，避免使用者过快增长。发展用户就像一种优化过程，明智的做法就是放慢速度。
</p>

<p>
Users are a double-edged sword. They can help you improve your language, but they can also deter you from improving it. So choose your users carefully, and be slow to grow their number. Having users is like optimization: the wise course is to delay it.
</p>
</blockquote>

<blockquote>
<p>
这种语言的句法短到令人生疑。你输入的命令中，没有任何一个字母是多余的，甚至用到 Shift 键的机会也很少。
</p>

<p>
The syntax of the language is brief to a fault. You never have to type an unnecessary character, or even use the Shift key much.
</p>

<p>
这种语言的抽象程度很高，使得你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个真正出色的性能分析器，告诉你应该重点关注什么地方。
</p>

<p>
Using big abstractions you can write the first version of a program very quickly. Later, when you want to optimize, there’s a really good profiler that tells you where to focus your attention.
</p>

<p>
这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册，它本身很薄，里面关于限定条件和例外情况的警告寥寥无几。
</p>

<p>
There are lots of good examples to learn from, and the language is intuitive enough that you can learn how to use it from examples in a couple minutes. You don’t need to look in the manual much. The manual is thin, and has few warnings and qualifications.
</p>

<p>
这种语言的内核很小，但很强大。各个函数库高度独立，而且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样完美契合，不需要为了兼容性问题放弃或者保留某些功能。所有函数库的源码都很容易得到。
</p>

<p>
The language has asmall core, and powerful, highly orthogonal libraries that are as carefully designed as the core language. The libraries all work well together; everything in the language fits together like the parts in a fine camera. Nothing is deprecated or retained for compatibility. The source code of all the libraries is readily available.
</p>

<p>
这种语言能够很轻松地与操作系统和用其他语言开发的应用程序对话。
</p>

<p>
It’s easy to talk to the operating system and to applications written in other languages.
</p>

<p>
这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。
</p>

<p>
The language is built in layers. The higher-level abstractions are built in a transparent way out of lower-level abstractions, which you can get hold of if you want.
</p>

<p>
除了一些绝对必要隐藏的东西，这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。
</p>

<p>
Nothing is hidden from you that doesn’t absolutely have to be. The language offers abstractions only as a way of saving you work, rather than as a way of telling you what to do.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> 第十五章</h2>
<div class="outline-text-2" id="text-17">
<p>
设计与研究（Design and Research）
</p>

<blockquote>
<p>
设计与研究的区别看来就在于，前者追求「好」，后者追求「新」。优秀的设计不一定很「新」，但必须是「好」的；优秀的研究不一定很「好」，但必须是「新」的。
</p>

<p>
The difference between design and research seems to be a question of new versus good. Design doesn’t have to be new, but it has to be good. Research doesn’t have to be good, but it has to be new.
</p>
</blockquote>

<blockquote>
<p>
让用户满意并不等于迎合用户的一切要求。用户不了解所有可能的选择，也经常弄错自己真正想要的东西。
</p>

<p>
Making what works for the user doesn’t mean simply making what the user tells you to. Users don’t know what all the choices are, and are often mistaken about what they really want.
</p>
</blockquote>

<blockquote>
<p>
如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。C、Lisp 和 Smalltalk 都是设计者为了自己使用而设计的，而 Cobol、Ada 和 Java 则是为了给别人使用而设计的。
</p>

<p>
You’re most likely to get good design if the intended users include the designer himself. C, Lisp, and Smalltalk were created for their own designers to use. Cobol, Ada, and Java were created for other people to use.
</p>
</blockquote>

<blockquote>
<p>
你不要把编程语言看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。
</p>
</blockquote>

<blockquote>
<p>
软件领域以外的人可能没听过「弱即是强」，所以意识不到这种模式在艺术领域普遍存在。以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。
</p>

<p>
What people outside the software world may not realize is that Worse is Better is found throughout the arts. In drawing, for example, the idea was discovered during the Renaissance. Now almost every drawing teacher will tell you that the right way to get an accurate drawing is not to work your way slowly around the contour of an object, because errors will accumulate and you’ll find at the end that the lines don’t meet. Instead you should draw a few quick lines in roughly the right place, and then gradually refine this initial sketch.
</p>
</blockquote>

<blockquote>
<p>
画家之间甚至流传着一句谚语：「画作永远没有完工的一天，你只是不再画下去而已。」这种情况对于第一线的程序员真是再熟悉不过了。
</p>

<p>
there is even a saying among painters: “A painting is never finished. You just stop working on it.” This idea will be familiar to anyone who has worked on software.
</p>
</blockquote>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2016-10-04 周二 22:22</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.5h)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
